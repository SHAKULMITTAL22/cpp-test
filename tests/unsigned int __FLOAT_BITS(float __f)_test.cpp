// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <cmath>
#include <limits>
#include <cassert>
#include <iostream>

// Function under test
static __inline unsigned __FLOAT_BITS(float __f)
{
    union {float __f; unsigned __i;} __u;
    __u.__f = __f;
    return __u.__i;
}

// Test suite for __FLOAT_BITS function
class FloatBitsTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup code if needed
    }

    void TearDown() override {
        // Cleanup code if needed
    }
};

// Positive test cases
TEST_F(FloatBitsTest, PositiveFloatValue) {
    // Test with a positive float value
    float test_value = 3.14159f;
    unsigned int result = __FLOAT_BITS(test_value);
    
    // Verify that the result is non-zero for a positive float
    EXPECT_NE(result, 0u);
    
    // Verify that we can reconstruct the original value
    union {float __f; unsigned __i;} verify_union;
    verify_union.__i = result;
    EXPECT_FLOAT_EQ(verify_union.__f, test_value);
}

TEST_F(FloatBitsTest, SmallPositiveFloatValue) {
    // Test with a small positive float value
    float test_value = 0.000001f;
    unsigned int result = __FLOAT_BITS(test_value);
    
    // Verify that the result is non-zero
    EXPECT_NE(result, 0u);
    
    // Verify reconstruction
    union {float __f; unsigned __i;} verify_union;
    verify_union.__i = result;
    EXPECT_FLOAT_EQ(verify_union.__f, test_value);
}

// Negative test cases
TEST_F(FloatBitsTest, NegativeFloatValue) {
    // Test with a negative float value
    float test_value = -2.71828f;
    unsigned int result = __FLOAT_BITS(test_value);
    
    // Verify that the sign bit is set (MSB should be 1 for negative numbers)
    EXPECT_NE(result & 0x80000000u, 0u);
    
    // Verify reconstruction
    union {float __f; unsigned __i;} verify_union;
    verify_union.__i = result;
    EXPECT_FLOAT_EQ(verify_union.__f, test_value);
}

TEST_F(FloatBitsTest, LargeNegativeFloatValue) {
    // Test with a large negative float value
    float test_value = -12345.6789f;
    unsigned int result = __FLOAT_BITS(test_value);
    
    // Verify that the sign bit is set
    EXPECT_NE(result & 0x80000000u, 0u);
    
    // Verify reconstruction
    union {float __f; unsigned __i;} verify_union;
    verify_union.__i = result;
    EXPECT_FLOAT_EQ(verify_union.__f, test_value);
}

// Edge case tests
TEST_F(FloatBitsTest, ZeroValue) {
    // Test with positive zero
    float test_value = 0.0f;
    unsigned int result = __FLOAT_BITS(test_value);
    
    // Positive zero should have all bits as 0
    EXPECT_EQ(result, 0u);
    
    // Verify reconstruction
    union {float __f; unsigned __i;} verify_union;
    verify_union.__i = result;
    EXPECT_FLOAT_EQ(verify_union.__f, test_value);
}

TEST_F(FloatBitsTest, NegativeZero) {
    // Test with negative zero
    float test_value = -0.0f;
    unsigned int result = __FLOAT_BITS(test_value);
    
    // Negative zero should have only the sign bit set
    EXPECT_EQ(result, 0x80000000u);
    
    // Verify reconstruction
    union {float __f; unsigned __i;} verify_union;
    verify_union.__i = result;
    EXPECT_FLOAT_EQ(verify_union.__f, test_value);
}

TEST_F(FloatBitsTest, PositiveInfinity) {
    // Test with positive infinity
    float test_value = std::numeric_limits<float>::infinity();
    unsigned int result = __FLOAT_BITS(test_value);
    
    // Positive infinity should have exponent bits all set and mantissa zero
    // IEEE 754: sign=0, exponent=0xFF, mantissa=0
    EXPECT_EQ(result, 0x7F800000u);
    
    // Verify reconstruction
    union {float __f; unsigned __i;} verify_union;
    verify_union.__i = result;
    EXPECT_TRUE(std::isinf(verify_union.__f));
    EXPECT_GT(verify_union.__f, 0.0f);
}

TEST_F(FloatBitsTest, NegativeInfinity) {
    // Test with negative infinity
    float test_value = -std::numeric_limits<float>::infinity();
    unsigned int result = __FLOAT_BITS(test_value);
    
    // Negative infinity should have sign bit set, exponent bits all set, mantissa zero
    // IEEE 754: sign=1, exponent=0xFF, mantissa=0
    EXPECT_EQ(result, 0xFF800000u);
    
    // Verify reconstruction
    union {float __f; unsigned __i;} verify_union;
    verify_union.__i = result;
    EXPECT_TRUE(std::isinf(verify_union.__f));
    EXPECT_LT(verify_union.__f, 0.0f);
}

TEST_F(FloatBitsTest, NaNValue) {
    // Test with NaN (Not a Number)
    float test_value = std::numeric_limits<float>::quiet_NaN();
    unsigned int result = __FLOAT_BITS(test_value);
    
    // NaN should have exponent bits all set and non-zero mantissa
    // Check that exponent is 0xFF (bits 23-30)
    EXPECT_EQ((result >> 23) & 0xFF, 0xFF);
    // Check that mantissa is non-zero (bits 0-22)
    EXPECT_NE(result & 0x7FFFFF, 0u);
    
    // Verify reconstruction produces NaN
    union {float __f; unsigned __i;} verify_union;
    verify_union.__i = result;
    EXPECT_TRUE(std::isnan(verify_union.__f));
}

TEST_F(FloatBitsTest, MaxFloatValue) {
    // Test with maximum finite float value
    float test_value = std::numeric_limits<float>::max();
    unsigned int result = __FLOAT_BITS(test_value);
    
    // Max float should have specific bit pattern
    EXPECT_NE(result, 0u);
    
    // Verify reconstruction
    union {float __f; unsigned __i;} verify_union;
    verify_union.__i = result;
    EXPECT_FLOAT_EQ(verify_union.__f, test_value);
}

TEST_F(FloatBitsTest, MinFloatValue) {
    // Test with minimum positive normalized float value
    float test_value = std::numeric_limits<float>::min();
    unsigned int result = __FLOAT_BITS(test_value);
    
    // Min normalized float should have specific bit pattern
    EXPECT_NE(result, 0u);
    
    // Verify reconstruction
    union {float __f; unsigned __i;} verify_union;
    verify_union.__i = result;
    EXPECT_FLOAT_EQ(verify_union.__f, test_value);
}

TEST_F(FloatBitsTest, DenormalizedValue) {
    // Test with a denormalized (subnormal) float value
    float test_value = std::numeric_limits<float>::denorm_min();
    unsigned int result = __FLOAT_BITS(test_value);
    
    // Denormalized values should have zero exponent and non-zero mantissa
    EXPECT_EQ((result >> 23) & 0xFF, 0); // Exponent should be 0
    EXPECT_NE(result & 0x7FFFFF, 0u);    // Mantissa should be non-zero
    
    // Verify reconstruction
    union {float __f; unsigned __i;} verify_union;
    verify_union.__i = result;
    EXPECT_FLOAT_EQ(verify_union.__f, test_value);
}

// Main function to run all tests
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
