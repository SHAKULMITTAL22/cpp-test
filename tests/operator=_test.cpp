// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <exception>
#include <stdexcept>
#include <memory>

// Test fixture for exception_ptr move assignment operator tests
class ExceptionPtrMoveAssignmentTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Create test exceptions for use in tests
        try {
            throw std::runtime_error("Test runtime error");
        } catch (...) {
            runtime_error_ptr = std::current_exception();
        }

        try {
            throw std::invalid_argument("Test invalid argument");
        } catch (...) {
            invalid_arg_ptr = std::current_exception();
        }

        try {
            throw std::logic_error("Test logic error");
        } catch (...) {
            logic_error_ptr = std::current_exception();
        }
    }

    std::exception_ptr runtime_error_ptr;
    std::exception_ptr invalid_arg_ptr;
    std::exception_ptr logic_error_ptr;
};

// Positive Test Case 1: Move assignment with valid exception_ptr
TEST_F(ExceptionPtrMoveAssignmentTest, MoveAssignmentWithValidExceptionPtr) {
    std::exception_ptr target_ptr;
    std::exception_ptr source_ptr = runtime_error_ptr;
    
    // Perform move assignment
    target_ptr = std::move(source_ptr);
    
    // Verify that target now holds the exception
    EXPECT_NE(target_ptr, nullptr);
    
    // Verify we can rethrow the moved exception
    try {
        std::rethrow_exception(target_ptr);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::runtime_error& e) {
        EXPECT_STREQ(e.what(), "Test runtime error");
    } catch (...) {
        FAIL() << "Expected std::runtime_error";
    }
}

// Positive Test Case 2: Move assignment between two non-null exception_ptrs
TEST_F(ExceptionPtrMoveAssignmentTest, MoveAssignmentBetweenNonNullExceptionPtrs) {
    std::exception_ptr target_ptr = invalid_arg_ptr;
    std::exception_ptr source_ptr = logic_error_ptr;
    
    // Perform move assignment (should replace target's content)
    target_ptr = std::move(source_ptr);
    
    // Verify that target now holds the logic_error exception
    EXPECT_NE(target_ptr, nullptr);
    
    try {
        std::rethrow_exception(target_ptr);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::logic_error& e) {
        EXPECT_STREQ(e.what(), "Test logic error");
    } catch (...) {
        FAIL() << "Expected std::logic_error";
    }
}

// Positive Test Case 3: Chained move assignments
TEST_F(ExceptionPtrMoveAssignmentTest, ChainedMoveAssignments) {
    std::exception_ptr ptr1, ptr2, ptr3;
    std::exception_ptr source = runtime_error_ptr;
    
    // Chain move assignments
    ptr3 = ptr2 = ptr1 = std::move(source);
    
    // All pointers should now hold the same exception
    EXPECT_NE(ptr1, nullptr);
    EXPECT_NE(ptr2, nullptr);
    EXPECT_NE(ptr3, nullptr);
    
    // Verify all can rethrow the same exception
    for (auto& ptr : {ptr1, ptr2, ptr3}) {
        try {
            std::rethrow_exception(ptr);
            FAIL() << "Expected exception to be thrown";
        } catch (const std::runtime_error& e) {
            EXPECT_STREQ(e.what(), "Test runtime error");
        } catch (...) {
            FAIL() << "Expected std::runtime_error";
        }
    }
}

// Negative Test Case 1: Move assignment from null exception_ptr
TEST_F(ExceptionPtrMoveAssignmentTest, MoveAssignmentFromNullExceptionPtr) {
    std::exception_ptr target_ptr = runtime_error_ptr;
    std::exception_ptr null_source_ptr; // Default constructed (null)
    
    // Perform move assignment from null
    target_ptr = std::move(null_source_ptr);
    
    // Target should now be null
    EXPECT_EQ(target_ptr, nullptr);
    
    // Attempting to rethrow should do nothing (no exception thrown)
    EXPECT_NO_THROW(std::rethrow_exception(target_ptr));
}

// Negative Test Case 2: Move assignment to already null exception_ptr
TEST_F(ExceptionPtrMoveAssignmentTest, MoveAssignmentToNullExceptionPtr) {
    std::exception_ptr target_ptr; // Default constructed (null)
    std::exception_ptr null_source_ptr; // Also null
    
    // Perform move assignment from null to null
    target_ptr = std::move(null_source_ptr);
    
    // Both should remain null
    EXPECT_EQ(target_ptr, nullptr);
    EXPECT_EQ(null_source_ptr, nullptr);
    
    // No exception should be available for rethrowing
    EXPECT_NO_THROW(std::rethrow_exception(target_ptr));
}

// Edge Case Test 1: Self move assignment
TEST_F(ExceptionPtrMoveAssignmentTest, SelfMoveAssignment) {
    std::exception_ptr self_ptr = runtime_error_ptr;
    
    // Perform self move assignment
    self_ptr = std::move(self_ptr);
    
    // Should still hold the original exception
    EXPECT_NE(self_ptr, nullptr);
    
    try {
        std::rethrow_exception(self_ptr);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::runtime_error& e) {
        EXPECT_STREQ(e.what(), "Test runtime error");
    } catch (...) {
        FAIL() << "Expected std::runtime_error";
    }
}

// Edge Case Test 2: Move assignment with temporary exception_ptr
TEST_F(ExceptionPtrMoveAssignmentTest, MoveAssignmentWithTemporaryExceptionPtr) {
    std::exception_ptr target_ptr;
    
    // Create and move assign a temporary exception_ptr
    target_ptr = []() -> std::exception_ptr {
        try {
            throw std::out_of_range("Temporary exception");
        } catch (...) {
            return std::current_exception();
        }
    }();
    
    // Verify the temporary was properly moved
    EXPECT_NE(target_ptr, nullptr);
    
    try {
        std::rethrow_exception(target_ptr);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::out_of_range& e) {
        EXPECT_STREQ(e.what(), "Temporary exception");
    } catch (...) {
        FAIL() << "Expected std::out_of_range";
    }
}

// Edge Case Test 3: Multiple consecutive move assignments
TEST_F(ExceptionPtrMoveAssignmentTest, MultipleConsecutiveMoveAssignments) {
    std::exception_ptr target_ptr;
    
    // Perform multiple move assignments in sequence
    target_ptr = std::move(runtime_error_ptr);
    target_ptr = std::move(invalid_arg_ptr);
    target_ptr = std::move(logic_error_ptr);
    
    // Should hold the last assigned exception
    EXPECT_NE(target_ptr, nullptr);
    
    try {
        std::rethrow_exception(target_ptr);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::logic_error& e) {
        EXPECT_STREQ(e.what(), "Test logic error");
    } catch (...) {
        FAIL() << "Expected std::logic_error";
    }
}

// Test for noexcept specification compliance
TEST_F(ExceptionPtrMoveAssignmentTest, NoexceptComplianceTest) {
    std::exception_ptr target_ptr;
    std::exception_ptr source_ptr = runtime_error_ptr;
    
    // Verify that move assignment is noexcept
    static_assert(noexcept(target_ptr = std::move(source_ptr)), 
                  "Move assignment operator should be noexcept");
    
    // This test passes if compilation succeeds
    SUCCEED();
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
