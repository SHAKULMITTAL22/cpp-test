// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <system_error>
#include <iostream>
#include <cassert>
#include <cmath>

// Test fixture for error_condition assign method tests
class ErrorConditionAssignTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Initialize error_condition object for testing
        error_cond = std::error_condition();
    }

    void TearDown() override {
        // Clean up after each test
    }

    std::error_condition error_cond;
};

// Test suite for std::error_condition::assign method
TEST_F(ErrorConditionAssignTest, AssignValidValueAndGenericCategory_SetsCorrectValues) {
    // Arrange
    int test_value = 42;
    const std::error_category& test_category = std::generic_category();
    
    // Act
    error_cond.assign(test_value, test_category);
    
    // Assert
    EXPECT_EQ(error_cond.value(), test_value);
    EXPECT_EQ(&error_cond.category(), &test_category);
}

TEST_F(ErrorConditionAssignTest, AssignValidValueAndSystemCategory_SetsCorrectValues) {
    // Arrange
    int test_value = 100;
    const std::error_category& test_category = std::system_category();
    
    // Act
    error_cond.assign(test_value, test_category);
    
    // Assert
    EXPECT_EQ(error_cond.value(), test_value);
    EXPECT_EQ(&error_cond.category(), &test_category);
}

TEST_F(ErrorConditionAssignTest, AssignZeroValue_SetsZeroValueCorrectly) {
    // Arrange
    int test_value = 0;
    const std::error_category& test_category = std::generic_category();
    
    // Act
    error_cond.assign(test_value, test_category);
    
    // Assert
    EXPECT_EQ(error_cond.value(), 0);
    EXPECT_EQ(&error_cond.category(), &test_category);
    EXPECT_FALSE(error_cond); // Zero value should evaluate to false
}

TEST_F(ErrorConditionAssignTest, AssignNegativeValue_SetsNegativeValueCorrectly) {
    // Arrange
    int test_value = -1;
    const std::error_category& test_category = std::system_category();
    
    // Act
    error_cond.assign(test_value, test_category);
    
    // Assert
    EXPECT_EQ(error_cond.value(), -1);
    EXPECT_EQ(&error_cond.category(), &test_category);
}

TEST_F(ErrorConditionAssignTest, AssignLargeNegativeValue_HandlesNegativeValueCorrectly) {
    // Arrange
    int test_value = -999;
    const std::error_category& test_category = std::generic_category();
    
    // Act
    error_cond.assign(test_value, test_category);
    
    // Assert
    EXPECT_EQ(error_cond.value(), -999);
    EXPECT_EQ(&error_cond.category(), &test_category);
}

TEST_F(ErrorConditionAssignTest, AssignMaxIntValue_HandlesMaximumValueCorrectly) {
    // Arrange
    int test_value = std::numeric_limits<int>::max();
    const std::error_category& test_category = std::system_category();
    
    // Act
    error_cond.assign(test_value, test_category);
    
    // Assert
    EXPECT_EQ(error_cond.value(), std::numeric_limits<int>::max());
    EXPECT_EQ(&error_cond.category(), &test_category);
}

TEST_F(ErrorConditionAssignTest, AssignMinIntValue_HandlesMinimumValueCorrectly) {
    // Arrange
    int test_value = std::numeric_limits<int>::min();
    const std::error_category& test_category = std::generic_category();
    
    // Act
    error_cond.assign(test_value, test_category);
    
    // Assert
    EXPECT_EQ(error_cond.value(), std::numeric_limits<int>::min());
    EXPECT_EQ(&error_cond.category(), &test_category);
}

TEST_F(ErrorConditionAssignTest, AssignMultipleTimes_OverwritesPreviousValues) {
    // Arrange
    int first_value = 10;
    int second_value = 20;
    const std::error_category& first_category = std::generic_category();
    const std::error_category& second_category = std::system_category();
    
    // Act
    error_cond.assign(first_value, first_category);
    error_cond.assign(second_value, second_category);
    
    // Assert
    EXPECT_EQ(error_cond.value(), second_value);
    EXPECT_EQ(&error_cond.category(), &second_category);
    EXPECT_NE(error_cond.value(), first_value);
    EXPECT_NE(&error_cond.category(), &first_category);
}

TEST_F(ErrorConditionAssignTest, AssignSameValueDifferentCategory_UpdatesCategoryCorrectly) {
    // Arrange
    int test_value = 50;
    const std::error_category& first_category = std::generic_category();
    const std::error_category& second_category = std::system_category();
    
    // Act
    error_cond.assign(test_value, first_category);
    error_cond.assign(test_value, second_category);
    
    // Assert
    EXPECT_EQ(error_cond.value(), test_value);
    EXPECT_EQ(&error_cond.category(), &second_category);
    EXPECT_NE(&error_cond.category(), &first_category);
}

TEST_F(ErrorConditionAssignTest, AssignSameCategoryDifferentValue_UpdatesValueCorrectly) {
    // Arrange
    int first_value = 30;
    int second_value = 60;
    const std::error_category& test_category = std::generic_category();
    
    // Act
    error_cond.assign(first_value, test_category);
    error_cond.assign(second_value, test_category);
    
    // Assert
    EXPECT_EQ(error_cond.value(), second_value);
    EXPECT_EQ(&error_cond.category(), &test_category);
    EXPECT_NE(error_cond.value(), first_value);
}

// Test for noexcept specification - this test verifies the method doesn't throw
TEST_F(ErrorConditionAssignTest, AssignMethod_IsNoexcept) {
    // Arrange
    int test_value = 123;
    const std::error_category& test_category = std::system_category();
    
    // Act & Assert - This should compile and not throw
    EXPECT_NO_THROW(error_cond.assign(test_value, test_category));
    
    // Verify the assignment worked correctly
    EXPECT_EQ(error_cond.value(), test_value);
    EXPECT_EQ(&error_cond.category(), &test_category);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
