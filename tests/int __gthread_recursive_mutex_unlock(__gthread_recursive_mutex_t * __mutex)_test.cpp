// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <cassert>
#include <cmath>
#include <iostream>
#include <pthread.h>

// Mock implementation for testing purposes
// Since __gthread_recursive_mutex_t and __gthread_mutex_unlock are typically 
// internal GCC threading primitives, we'll create mock versions for testing

// Mock mutex structure
struct __gthread_recursive_mutex_t {
    pthread_mutex_t mutex;
    int lock_count;
    pthread_t owner;
    bool initialized;
    
    __gthread_recursive_mutex_t() : lock_count(0), owner(0), initialized(false) {
        pthread_mutexattr_t attr;
        pthread_mutexattr_init(&attr);
        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
        pthread_mutex_init(&mutex, &attr);
        pthread_mutexattr_destroy(&attr);
        initialized = true;
    }
    
    ~__gthread_recursive_mutex_t() {
        if (initialized) {
            pthread_mutex_destroy(&mutex);
        }
    }
};

// Mock implementation of __gthread_mutex_unlock
int __gthread_mutex_unlock(__gthread_recursive_mutex_t* mutex) {
    if (!mutex || !mutex->initialized) {
        return -1; // Error: invalid mutex
    }
    
    pthread_t current_thread = pthread_self();
    
    // Check if current thread owns the mutex
    if (mutex->lock_count == 0 || !pthread_equal(mutex->owner, current_thread)) {
        return -2; // Error: mutex not owned by current thread
    }
    
    mutex->lock_count--;
    
    if (mutex->lock_count == 0) {
        mutex->owner = 0;
    }
    
    return pthread_mutex_unlock(&mutex->mutex);
}

// Function under test
static inline int
__gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex)
{
    return __gthread_mutex_unlock(__mutex);
}

// Test Suite for __gthread_recursive_mutex_unlock
class GThreadRecursiveMutexUnlockTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Initialize test mutex
        test_mutex = new __gthread_recursive_mutex_t();
    }
    
    void TearDown() override {
        delete test_mutex;
    }
    
    __gthread_recursive_mutex_t* test_mutex;
    
    // Helper function to lock mutex for testing unlock scenarios
    void lockMutex(__gthread_recursive_mutex_t* mutex, int times = 1) {
        for (int i = 0; i < times; ++i) {
            pthread_mutex_lock(&mutex->mutex);
            mutex->lock_count++;
            mutex->owner = pthread_self();
        }
    }
};

// Positive Test Cases
TEST_F(GThreadRecursiveMutexUnlockTest, UnlockValidMutex_Success) {
    // Arrange: Lock the mutex first
    lockMutex(test_mutex);
    
    // Act: Unlock the mutex
    int result = __gthread_recursive_mutex_unlock(test_mutex);
    
    // Assert: Should return 0 (success)
    EXPECT_EQ(0, result);
    EXPECT_EQ(0, test_mutex->lock_count);
}

TEST_F(GThreadRecursiveMutexUnlockTest, UnlockRecursivelyLockedMutex_Success) {
    // Arrange: Lock the mutex multiple times recursively
    lockMutex(test_mutex, 3);
    
    // Act: Unlock once
    int result = __gthread_recursive_mutex_unlock(test_mutex);
    
    // Assert: Should return 0 and decrease lock count
    EXPECT_EQ(0, result);
    EXPECT_EQ(2, test_mutex->lock_count);
    EXPECT_TRUE(pthread_equal(test_mutex->owner, pthread_self()));
}

// Negative Test Cases
TEST_F(GThreadRecursiveMutexUnlockTest, UnlockNullMutex_ReturnsError) {
    // Arrange: Use null pointer
    __gthread_recursive_mutex_t* null_mutex = nullptr;
    
    // Act: Attempt to unlock null mutex
    int result = __gthread_recursive_mutex_unlock(null_mutex);
    
    // Assert: Should return error code
    EXPECT_EQ(-1, result);
}

TEST_F(GThreadRecursiveMutexUnlockTest, UnlockUnlockedMutex_ReturnsError) {
    // Arrange: Mutex is already unlocked (default state)
    
    // Act: Attempt to unlock already unlocked mutex
    int result = __gthread_recursive_mutex_unlock(test_mutex);
    
    // Assert: Should return error code
    EXPECT_EQ(-2, result);
}

// Edge Case Tests
TEST_F(GThreadRecursiveMutexUnlockTest, UnlockUninitializedMutex_ReturnsError) {
    // Arrange: Create uninitialized mutex
    __gthread_recursive_mutex_t uninitialized_mutex;
    uninitialized_mutex.initialized = false;
    uninitialized_mutex.lock_count = 0;
    
    // Act: Attempt to unlock uninitialized mutex
    int result = __gthread_recursive_mutex_unlock(&uninitialized_mutex);
    
    // Assert: Should return error code
    EXPECT_EQ(-1, result);
}

TEST_F(GThreadRecursiveMutexUnlockTest, UnlockAfterMaxRecursiveLocks_Success) {
    // Arrange: Lock mutex maximum recursive times (simulate deep recursion)
    const int max_recursive_locks = 100;
    lockMutex(test_mutex, max_recursive_locks);
    
    // Act: Unlock once
    int result = __gthread_recursive_mutex_unlock(test_mutex);
    
    // Assert: Should successfully unlock and maintain correct count
    EXPECT_EQ(0, result);
    EXPECT_EQ(max_recursive_locks - 1, test_mutex->lock_count);
    EXPECT_TRUE(pthread_equal(test_mutex->owner, pthread_self()));
}

TEST_F(GThreadRecursiveMutexUnlockTest, UnlockLastRecursiveLock_ClearsOwnership) {
    // Arrange: Lock mutex once
    lockMutex(test_mutex, 1);
    
    // Act: Unlock the last lock
    int result = __gthread_recursive_mutex_unlock(test_mutex);
    
    // Assert: Should clear ownership and reset lock count
    EXPECT_EQ(0, result);
    EXPECT_EQ(0, test_mutex->lock_count);
    EXPECT_EQ(0, test_mutex->owner);
}

// Test Suite for Error Handling
class GThreadRecursiveMutexUnlockErrorTest : public ::testing::Test {
protected:
    void SetUp() override {
        corrupted_mutex = new __gthread_recursive_mutex_t();
    }
    
    void TearDown() override {
        delete corrupted_mutex;
    }
    
    __gthread_recursive_mutex_t* corrupted_mutex;
};

TEST_F(GThreadRecursiveMutexUnlockErrorTest, UnlockCorruptedMutex_HandlesGracefully) {
    // Arrange: Simulate corrupted mutex state
    corrupted_mutex->initialized = false;
    corrupted_mutex->lock_count = -1; // Invalid state
    
    // Act: Attempt to unlock corrupted mutex
    int result = __gthread_recursive_mutex_unlock(corrupted_mutex);
    
    // Assert: Should handle error gracefully
    EXPECT_NE(0, result); // Should return non-zero error code
}

TEST_F(GThreadRecursiveMutexUnlockErrorTest, UnlockWithInvalidLockCount_ReturnsError) {
    // Arrange: Set invalid lock count
    corrupted_mutex->lock_count = 0;
    corrupted_mutex->owner = pthread_self();
    
    // Act: Attempt to unlock
    int result = __gthread_recursive_mutex_unlock(corrupted_mutex);
    
    // Assert: Should return error for inconsistent state
    EXPECT_EQ(-2, result);
}

// Main function to run all tests
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
