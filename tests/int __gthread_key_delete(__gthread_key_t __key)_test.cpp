// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <pthread.h>
#include <cassert>
#include <cmath>
#include <iostream>

// Forward declaration of the function under test
extern "C" {
    int __gthread_key_delete(__gthread_key_t __key);
}

// Test suite for __gthread_key_delete function
class GThreadKeyDeleteTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup code if needed
    }

    void TearDown() override {
        // Cleanup code if needed
    }

    // Helper function to create a valid pthread key
    pthread_key_t createValidKey() {
        pthread_key_t key;
        int result = pthread_key_create(&key, nullptr);
        if (result != 0) {
            return static_cast<pthread_key_t>(-1); // Invalid key indicator
        }
        return key;
    }
};

// Positive Test Cases
TEST_F(GThreadKeyDeleteTest, DeleteValidKey_ReturnsSuccess) {
    // Create a valid key first
    pthread_key_t validKey = createValidKey();
    ASSERT_NE(validKey, static_cast<pthread_key_t>(-1)) << "Failed to create valid key for test";

    // Test deleting the valid key
    int result = __gthread_key_delete(validKey);
    
    // Should return 0 on success
    EXPECT_EQ(result, 0) << "Expected successful deletion of valid key";
}

TEST_F(GThreadKeyDeleteTest, DeleteMultipleValidKeys_AllReturnSuccess) {
    // Create multiple valid keys
    const int numKeys = 3;
    pthread_key_t keys[numKeys];
    
    // Create keys
    for (int i = 0; i < numKeys; ++i) {
        keys[i] = createValidKey();
        ASSERT_NE(keys[i], static_cast<pthread_key_t>(-1)) << "Failed to create valid key " << i;
    }
    
    // Delete all keys and verify success
    for (int i = 0; i < numKeys; ++i) {
        int result = __gthread_key_delete(keys[i]);
        EXPECT_EQ(result, 0) << "Expected successful deletion of key " << i;
    }
}

// Negative Test Cases
TEST_F(GThreadKeyDeleteTest, DeleteInvalidKey_ReturnsError) {
    // Use an obviously invalid key value
    pthread_key_t invalidKey = static_cast<pthread_key_t>(-1);
    
    int result = __gthread_key_delete(invalidKey);
    
    // Should return non-zero error code (typically EINVAL)
    EXPECT_NE(result, 0) << "Expected error when deleting invalid key";
}

TEST_F(GThreadKeyDeleteTest, DeleteAlreadyDeletedKey_ReturnsError) {
    // Create a valid key first
    pthread_key_t validKey = createValidKey();
    ASSERT_NE(validKey, static_cast<pthread_key_t>(-1)) << "Failed to create valid key for test";
    
    // Delete the key once (should succeed)
    int firstResult = __gthread_key_delete(validKey);
    EXPECT_EQ(firstResult, 0) << "First deletion should succeed";
    
    // Try to delete the same key again (should fail)
    int secondResult = __gthread_key_delete(validKey);
    EXPECT_NE(secondResult, 0) << "Second deletion of same key should fail";
}

// Edge Case Tests
TEST_F(GThreadKeyDeleteTest, DeleteKeyWithZeroValue_HandlesGracefully) {
    // Test with key value of 0, which might be a special case
    pthread_key_t zeroKey = static_cast<pthread_key_t>(0);
    
    int result = __gthread_key_delete(zeroKey);
    
    // The behavior may vary by implementation, but should not crash
    // We just verify the function completes and returns some value
    EXPECT_TRUE(result == 0 || result != 0) << "Function should complete without crashing";
}

TEST_F(GThreadKeyDeleteTest, DeleteKeyWithMaxValue_HandlesGracefully) {
    // Test with maximum possible key value
    pthread_key_t maxKey = static_cast<pthread_key_t>(PTHREAD_KEYS_MAX - 1);
    
    int result = __gthread_key_delete(maxKey);
    
    // Should handle gracefully, likely returning an error for invalid key
    EXPECT_NE(result, 0) << "Expected error for likely invalid max key value";
}

TEST_F(GThreadKeyDeleteTest, DeleteKeyAfterThreadExit_BehaviorConsistent) {
    // Create and immediately delete a key to test cleanup behavior
    pthread_key_t key = createValidKey();
    ASSERT_NE(key, static_cast<pthread_key_t>(-1)) << "Failed to create valid key for test";
    
    // Delete the key
    int result = __gthread_key_delete(key);
    EXPECT_EQ(result, 0) << "Key deletion should succeed";
    
    // Verify that subsequent operations on the key fail appropriately
    int secondResult = __gthread_key_delete(key);
    EXPECT_NE(secondResult, 0) << "Operations on deleted key should fail";
}

// Main function to run all tests
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    
    // Optional: Configure test output
    ::testing::FLAGS_gtest_color = "yes";
    ::testing::FLAGS_gtest_print_time = true;
    
    std::cout << "Running unit tests for __gthread_key_delete function..." << std::endl;
    
    int result = RUN_ALL_TESTS();
    
    if (result == 0) {
        std::cout << "All tests passed successfully!" << std::endl;
    } else {
        std::cout << "Some tests failed. Please review the output above." << std::endl;
    }
    
    return result;
}
