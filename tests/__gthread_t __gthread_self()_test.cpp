// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <pthread.h>
#include <thread>
#include <vector>
#include <set>
#include <chrono>

// Assuming the function is in a namespace or header - adjust as needed
// If the function is in a specific namespace, use the appropriate scope resolution
extern "C" {
    typedef pthread_t __gthread_t;
    static inline __gthread_t __gthread_self(void) {
        return pthread_self();
    }
}

// Test suite for __gthread_self function
class GThreadSelfTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup code if needed
    }
    
    void TearDown() override {
        // Cleanup code if needed
    }
};

// Positive Test Case 1: Verify function returns a valid thread ID
TEST_F(GThreadSelfTest, ReturnsValidThreadId) {
    __gthread_t thread_id = __gthread_self();
    
    // Thread ID should not be zero (invalid thread ID)
    EXPECT_NE(thread_id, static_cast<__gthread_t>(0));
    
    // Verify it's a valid pthread_t by comparing with pthread_self()
    EXPECT_EQ(thread_id, pthread_self());
}

// Positive Test Case 2: Verify consistency across multiple calls
TEST_F(GThreadSelfTest, ConsistentAcrossMultipleCalls) {
    __gthread_t first_call = __gthread_self();
    __gthread_t second_call = __gthread_self();
    __gthread_t third_call = __gthread_self();
    
    // All calls from the same thread should return the same ID
    EXPECT_EQ(first_call, second_call);
    EXPECT_EQ(second_call, third_call);
    EXPECT_EQ(first_call, third_call);
}

// Positive Test Case 3: Verify thread ID uniqueness across different threads
TEST_F(GThreadSelfTest, UniqueThreadIdsAcrossDifferentThreads) {
    std::vector<__gthread_t> thread_ids;
    std::vector<std::thread> threads;
    const int num_threads = 5;
    
    // Create multiple threads and collect their IDs
    for (int i = 0; i < num_threads; ++i) {
        threads.emplace_back([&thread_ids]() {
            __gthread_t id = __gthread_self();
            thread_ids.push_back(id);
        });
    }
    
    // Wait for all threads to complete
    for (auto& t : threads) {
        t.join();
    }
    
    // Convert to set to check uniqueness
    std::set<__gthread_t> unique_ids(thread_ids.begin(), thread_ids.end());
    
    // All thread IDs should be unique
    EXPECT_EQ(unique_ids.size(), thread_ids.size());
    EXPECT_EQ(unique_ids.size(), static_cast<size_t>(num_threads));
}

// Edge Case 1: Verify function works immediately after thread creation
TEST_F(GThreadSelfTest, WorksImmediatelyAfterThreadCreation) {
    __gthread_t main_thread_id = __gthread_self();
    __gthread_t child_thread_id;
    bool test_completed = false;
    
    std::thread test_thread([&]() {
        // Call __gthread_self immediately upon thread start
        child_thread_id = __gthread_self();
        test_completed = true;
    });
    
    test_thread.join();
    
    EXPECT_TRUE(test_completed);
    EXPECT_NE(child_thread_id, static_cast<__gthread_t>(0));
    EXPECT_NE(child_thread_id, main_thread_id);
}

// Edge Case 2: Verify function works with rapid successive calls
TEST_F(GThreadSelfTest, HandlesRapidSuccessiveCalls) {
    const int num_calls = 1000;
    __gthread_t first_id = __gthread_self();
    
    // Make rapid successive calls
    for (int i = 0; i < num_calls; ++i) {
        __gthread_t current_id = __gthread_self();
        EXPECT_EQ(current_id, first_id);
    }
}

// Negative Test Case 1: Verify main thread ID differs from child thread IDs
TEST_F(GThreadSelfTest, MainThreadDiffersFromChildThreads) {
    __gthread_t main_thread_id = __gthread_self();
    std::vector<__gthread_t> child_thread_ids;
    std::vector<std::thread> threads;
    
    // Create child threads
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back([&child_thread_ids]() {
            child_thread_ids.push_back(__gthread_self());
        });
    }
    
    // Wait for completion
    for (auto& t : threads) {
        t.join();
    }
    
    // Main thread ID should be different from all child thread IDs
    for (const auto& child_id : child_thread_ids) {
        EXPECT_NE(main_thread_id, child_id);
    }
}

// Negative Test Case 2: Verify thread IDs don't repeat after thread termination
TEST_F(GThreadSelfTest, ThreadIdsDoNotRepeatAfterTermination) {
    std::vector<__gthread_t> first_batch_ids;
    std::vector<__gthread_t> second_batch_ids;
    
    // First batch of threads
    {
        std::vector<std::thread> first_batch;
        for (int i = 0; i < 3; ++i) {
            first_batch.emplace_back([&first_batch_ids]() {
                first_batch_ids.push_back(__gthread_self());
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
            });
        }
        
        for (auto& t : first_batch) {
            t.join();
        }
    }
    
    // Small delay to ensure threads are fully cleaned up
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
    
    // Second batch of threads
    {
        std::vector<std::thread> second_batch;
        for (int i = 0; i < 3; ++i) {
            second_batch.emplace_back([&second_batch_ids]() {
                second_batch_ids.push_back(__gthread_self());
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
            });
        }
        
        for (auto& t : second_batch) {
            t.join();
        }
    }
    
    // Thread IDs from different batches should generally be different
    // Note: This test may occasionally fail due to thread ID reuse in some systems
    // but it's useful for detecting obvious issues
    std::set<__gthread_t> all_ids;
    all_ids.insert(first_batch_ids.begin(), first_batch_ids.end());
    all_ids.insert(second_batch_ids.begin(), second_batch_ids.end());
    
    // At minimum, we should have some unique IDs
    EXPECT_GE(all_ids.size(), 3u);
}

// Performance Test: Verify function executes quickly
TEST_F(GThreadSelfTest, ExecutesQuickly) {
    const int num_iterations = 10000;
    
    auto start_time = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < num_iterations; ++i) {
        volatile __gthread_t id = __gthread_self();
        (void)id; // Suppress unused variable warning
    }
    
    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
    
    // Function should execute very quickly - allow generous time for CI environments
    EXPECT_LT(duration.count(), 1000); // Less than 1 second for 10k calls
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
