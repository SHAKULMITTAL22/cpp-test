// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <system_error>
#include <cassert>
#include <cmath>
#include <iostream>

// Test suite for std::error_condition copy constructor
class ErrorConditionCopyConstructorTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup common test data
    }
    
    void TearDown() override {
        // Cleanup after tests
    }
};

// Positive Test Cases
TEST_F(ErrorConditionCopyConstructorTest, CopyConstructorWithValidErrorCondition) {
    // Create an original error_condition with a specific error code
    std::error_condition original(std::errc::invalid_argument);
    
    // Copy construct a new error_condition
    std::error_condition copied(original);
    
    // Verify that the copied object has the same properties as the original
    EXPECT_EQ(copied.value(), original.value());
    EXPECT_EQ(copied.category(), original.category());
    EXPECT_EQ(copied.message(), original.message());
    EXPECT_EQ(static_cast<bool>(copied), static_cast<bool>(original));
}

TEST_F(ErrorConditionCopyConstructorTest, CopyConstructorWithCustomErrorCondition) {
    // Create an error_condition with a different error code
    std::error_condition original(std::errc::permission_denied);
    
    // Copy construct a new error_condition
    std::error_condition copied(original);
    
    // Verify that the copied object maintains all properties
    EXPECT_EQ(copied.value(), original.value());
    EXPECT_EQ(copied.category(), original.category());
    EXPECT_EQ(copied.message(), original.message());
    EXPECT_TRUE(copied == original);
}

// Negative Test Cases
TEST_F(ErrorConditionCopyConstructorTest, CopyConstructorWithDefaultErrorCondition) {
    // Create a default error_condition (represents no error)
    std::error_condition original;
    
    // Copy construct from the default error_condition
    std::error_condition copied(original);
    
    // Verify that the copied object represents no error
    EXPECT_EQ(copied.value(), 0);
    EXPECT_EQ(copied.value(), original.value());
    EXPECT_EQ(copied.category(), original.category());
    EXPECT_FALSE(static_cast<bool>(copied));
    EXPECT_FALSE(static_cast<bool>(original));
}

TEST_F(ErrorConditionCopyConstructorTest, CopyConstructorIndependence) {
    // Create an original error_condition
    std::error_condition original(std::errc::operation_not_permitted);
    
    // Copy construct a new error_condition
    std::error_condition copied(original);
    
    // Verify initial equality
    EXPECT_EQ(copied.value(), original.value());
    
    // Modify the copied object by assigning a different error
    copied = std::error_condition(std::errc::no_such_file_or_directory);
    
    // Verify that the original remains unchanged
    EXPECT_NE(copied.value(), original.value());
    EXPECT_EQ(original.value(), static_cast<int>(std::errc::operation_not_permitted));
    EXPECT_EQ(copied.value(), static_cast<int>(std::errc::no_such_file_or_directory));
}

// Edge Case Test
TEST_F(ErrorConditionCopyConstructorTest, CopyConstructorWithZeroValueErrorCondition) {
    // Create an error_condition with explicit zero value (success condition)
    std::error_condition original(0, std::generic_category());
    
    // Copy construct from the zero-value error_condition
    std::error_condition copied(original);
    
    // Verify that the copied object maintains the zero value
    EXPECT_EQ(copied.value(), 0);
    EXPECT_EQ(copied.value(), original.value());
    EXPECT_EQ(copied.category(), original.category());
    EXPECT_FALSE(static_cast<bool>(copied));
    EXPECT_EQ(copied.category(), std::generic_category());
}

// Additional comprehensive test for copy constructor behavior
TEST_F(ErrorConditionCopyConstructorTest, CopyConstructorPreservesAllAttributes) {
    // Test with multiple different error conditions to ensure comprehensive coverage
    std::vector<std::errc> error_codes = {
        std::errc::address_family_not_supported,
        std::errc::address_in_use,
        std::errc::address_not_available,
        std::errc::already_connected,
        std::errc::argument_list_too_long
    };
    
    for (const auto& error_code : error_codes) {
        std::error_condition original(error_code);
        std::error_condition copied(original);
        
        // Verify all attributes are preserved
        EXPECT_EQ(copied.value(), original.value()) 
            << "Failed for error code: " << static_cast<int>(error_code);
        EXPECT_EQ(copied.category(), original.category())
            << "Failed for error code: " << static_cast<int>(error_code);
        EXPECT_EQ(copied.message(), original.message())
            << "Failed for error code: " << static_cast<int>(error_code);
        EXPECT_EQ(static_cast<bool>(copied), static_cast<bool>(original))
            << "Failed for error code: " << static_cast<int>(error_code);
    }
}

// Test for self-assignment safety (though copy constructor doesn't directly test this)
TEST_F(ErrorConditionCopyConstructorTest, CopyConstructorMemoryIntegrity) {
    // Create an error_condition
    std::error_condition original(std::errc::broken_pipe);
    
    // Create multiple copies to test memory integrity
    std::error_condition copy1(original);
    std::error_condition copy2(original);
    std::error_condition copy3(copy1);
    
    // Verify all copies are identical and independent
    EXPECT_EQ(copy1.value(), original.value());
    EXPECT_EQ(copy2.value(), original.value());
    EXPECT_EQ(copy3.value(), original.value());
    
    EXPECT_EQ(copy1.category(), original.category());
    EXPECT_EQ(copy2.category(), original.category());
    EXPECT_EQ(copy3.category(), original.category());
    
    // Verify they all represent the same error state
    EXPECT_TRUE(copy1 == original);
    EXPECT_TRUE(copy2 == original);
    EXPECT_TRUE(copy3 == original);
    EXPECT_TRUE(copy1 == copy2);
    EXPECT_TRUE(copy2 == copy3);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
