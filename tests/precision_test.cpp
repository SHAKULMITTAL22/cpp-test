// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <iostream>
#include <sstream>
#include <limits>

// Test fixture for ios_base precision function tests
class IosPrecisionTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Reset stream to default state before each test
        test_stream.precision(6); // Default precision
        test_stream.clear();
    }

    void TearDown() override {
        // Clean up after each test
        test_stream.clear();
    }

    std::ostringstream test_stream;
};

// Test Suite: Basic Functionality Tests
TEST_F(IosPrecisionTest, SetPrecisionReturnsOldValue) {
    // Test that setting precision returns the previous precision value
    std::streamsize initial_precision = test_stream.precision();
    std::streamsize old_precision = test_stream.precision(10);
    
    EXPECT_EQ(old_precision, initial_precision);
    EXPECT_EQ(test_stream.precision(), 10);
}

TEST_F(IosPrecisionTest, SetValidPrecisionValue) {
    // Test setting a valid precision value
    std::streamsize new_precision = 15;
    test_stream.precision(new_precision);
    
    EXPECT_EQ(test_stream.precision(), new_precision);
}

// Test Suite: Positive Test Cases
TEST_F(IosPrecisionTest, SetZeroPrecision) {
    // Test setting precision to zero (valid case)
    std::streamsize old_precision = test_stream.precision(0);
    
    EXPECT_GE(old_precision, 0);
    EXPECT_EQ(test_stream.precision(), 0);
}

TEST_F(IosPrecisionTest, SetLargePrecisionValue) {
    // Test setting a large precision value
    std::streamsize large_precision = 100;
    std::streamsize old_precision = test_stream.precision(large_precision);
    
    EXPECT_GE(old_precision, 0);
    EXPECT_EQ(test_stream.precision(), large_precision);
}

// Test Suite: Negative Test Cases
TEST_F(IosPrecisionTest, SetNegativePrecision) {
    // Test setting negative precision (implementation-defined behavior)
    std::streamsize negative_precision = -5;
    std::streamsize old_precision = test_stream.precision(negative_precision);
    
    EXPECT_GE(old_precision, 0);
    // Note: Behavior with negative precision is implementation-defined
    // We just verify the function doesn't crash and returns a valid old value
}

TEST_F(IosPrecisionTest, SetVeryLargeNegativePrecision) {
    // Test setting very large negative precision
    std::streamsize very_negative = std::numeric_limits<std::streamsize>::min();
    std::streamsize old_precision = test_stream.precision(very_negative);
    
    EXPECT_GE(old_precision, 0);
    // Function should not crash with extreme negative values
}

// Test Suite: Edge Cases
TEST_F(IosPrecisionTest, SetMaximumPrecisionValue) {
    // Test setting precision to maximum possible value
    std::streamsize max_precision = std::numeric_limits<std::streamsize>::max();
    std::streamsize old_precision = test_stream.precision(max_precision);
    
    EXPECT_GE(old_precision, 0);
    EXPECT_EQ(test_stream.precision(), max_precision);
}

// Test Suite: Sequential Operations
TEST_F(IosPrecisionTest, MultiplePrecisionChanges) {
    // Test multiple consecutive precision changes
    std::streamsize first_precision = 5;
    std::streamsize second_precision = 12;
    std::streamsize third_precision = 3;
    
    std::streamsize initial = test_stream.precision(first_precision);
    EXPECT_GE(initial, 0);
    EXPECT_EQ(test_stream.precision(), first_precision);
    
    std::streamsize old_first = test_stream.precision(second_precision);
    EXPECT_EQ(old_first, first_precision);
    EXPECT_EQ(test_stream.precision(), second_precision);
    
    std::streamsize old_second = test_stream.precision(third_precision);
    EXPECT_EQ(old_second, second_precision);
    EXPECT_EQ(test_stream.precision(), third_precision);
}

TEST_F(IosPrecisionTest, PrecisionConsistencyCheck) {
    // Test that precision value remains consistent between calls
    std::streamsize set_precision = 8;
    test_stream.precision(set_precision);
    
    // Multiple calls to precision() should return the same value
    EXPECT_EQ(test_stream.precision(), set_precision);
    EXPECT_EQ(test_stream.precision(), set_precision);
    EXPECT_EQ(test_stream.precision(), set_precision);
}

// Test Suite: Boundary Value Tests
TEST_F(IosPrecisionTest, BoundaryValueOne) {
    // Test precision value of 1 (common boundary)
    std::streamsize boundary_precision = 1;
    std::streamsize old_precision = test_stream.precision(boundary_precision);
    
    EXPECT_GE(old_precision, 0);
    EXPECT_EQ(test_stream.precision(), boundary_precision);
}

TEST_F(IosPrecisionTest, DefaultPrecisionBehavior) {
    // Test that default precision is reasonable and function works correctly
    std::streamsize current_precision = test_stream.precision();
    std::streamsize returned_precision = test_stream.precision(current_precision);
    
    EXPECT_EQ(returned_precision, current_precision);
    EXPECT_EQ(test_stream.precision(), current_precision);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
