// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <pthread.h>
#include <cassert>
#include <cmath>
#include <iostream>

// Mock definitions for testing
typedef pthread_mutex_t __gthread_recursive_mutex_t;

// Mock function declarations
extern "C" {
    int __gthread_active_p();
    int pthread_mutexattr_init(pthread_mutexattr_t *attr);
    int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
    int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
    int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
}

// Mock implementations for controlled testing
static bool mock_gthread_active = true;
static int mock_mutexattr_init_return = 0;
static int mock_mutexattr_settype_return = 0;
static int mock_mutex_init_return = 0;
static int mock_mutexattr_destroy_return = 0;

int __gthread_active_p() {
    return mock_gthread_active ? 1 : 0;
}

int pthread_mutexattr_init(pthread_mutexattr_t *attr) {
    return mock_mutexattr_init_return;
}

int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type) {
    return mock_mutexattr_settype_return;
}

int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr) {
    return mock_mutex_init_return;
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *attr) {
    return mock_mutexattr_destroy_return;
}

// Function under test
static inline int
__gthread_recursive_mutex_init_function(__gthread_recursive_mutex_t *__mutex)
{
    if (__gthread_active_p()) {
        pthread_mutexattr_t __attr;
        int __r;

        __r = pthread_mutexattr_init(&__attr);
        if (!__r)
            __r = pthread_mutexattr_settype(&__attr, PTHREAD_MUTEX_RECURSIVE);
        if (!__r)
            __r = pthread_mutex_init(__mutex, &__attr);
        if (!__r)
            __r = pthread_mutexattr_destroy(&__attr);
        return __r;
    }
    return 0;
}

// Test Suite for __gthread_recursive_mutex_init_function
class GThreadRecursiveMutexInitTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Reset mock states before each test
        mock_gthread_active = true;
        mock_mutexattr_init_return = 0;
        mock_mutexattr_settype_return = 0;
        mock_mutex_init_return = 0;
        mock_mutexattr_destroy_return = 0;
    }

    __gthread_recursive_mutex_t test_mutex;
};

// Positive Test Cases
TEST_F(GThreadRecursiveMutexInitTest, SuccessfulInitializationWhenThreadingActive) {
    // Test successful mutex initialization when threading is active
    int result = __gthread_recursive_mutex_init_function(&test_mutex);
    EXPECT_EQ(result, 0);
}

TEST_F(GThreadRecursiveMutexInitTest, ReturnsZeroWhenThreadingInactive) {
    // Test that function returns 0 when threading is not active
    mock_gthread_active = false;
    int result = __gthread_recursive_mutex_init_function(&test_mutex);
    EXPECT_EQ(result, 0);
}

// Negative Test Cases
TEST_F(GThreadRecursiveMutexInitTest, FailureInMutexAttrInit) {
    // Test failure when pthread_mutexattr_init fails
    mock_mutexattr_init_return = EINVAL;
    int result = __gthread_recursive_mutex_init_function(&test_mutex);
    EXPECT_EQ(result, EINVAL);
}

TEST_F(GThreadRecursiveMutexInitTest, FailureInMutexAttrSetType) {
    // Test failure when pthread_mutexattr_settype fails
    mock_mutexattr_settype_return = EINVAL;
    int result = __gthread_recursive_mutex_init_function(&test_mutex);
    EXPECT_EQ(result, EINVAL);
}

TEST_F(GThreadRecursiveMutexInitTest, FailureInMutexInit) {
    // Test failure when pthread_mutex_init fails
    mock_mutex_init_return = ENOMEM;
    int result = __gthread_recursive_mutex_init_function(&test_mutex);
    EXPECT_EQ(result, ENOMEM);
}

TEST_F(GThreadRecursiveMutexInitTest, FailureInMutexAttrDestroy) {
    // Test failure when pthread_mutexattr_destroy fails
    mock_mutexattr_destroy_return = EINVAL;
    int result = __gthread_recursive_mutex_init_function(&test_mutex);
    EXPECT_EQ(result, EINVAL);
}

// Edge Case Tests
TEST_F(GThreadRecursiveMutexInitTest, NullMutexPointer) {
    // Test behavior with null mutex pointer
    // Note: This may cause segmentation fault in real implementation
    // but we test the function's response to invalid input
    __gthread_recursive_mutex_t *null_mutex = nullptr;
    
    // Mock mutex_init to return error for null pointer
    mock_mutex_init_return = EINVAL;
    
    int result = __gthread_recursive_mutex_init_function(null_mutex);
    EXPECT_EQ(result, EINVAL);
}

TEST_F(GThreadRecursiveMutexInitTest, MultipleFailuresInSequence) {
    // Test that function stops at first failure and returns appropriate error
    mock_mutexattr_init_return = ENOMEM;
    mock_mutexattr_settype_return = EINVAL;  // This should not be reached
    
    int result = __gthread_recursive_mutex_init_function(&test_mutex);
    EXPECT_EQ(result, ENOMEM);
}

// Boundary Condition Tests
TEST_F(GThreadRecursiveMutexInitTest, ThreadingActiveStatusBoundary) {
    // Test the boundary condition when threading status changes
    mock_gthread_active = false;
    int result1 = __gthread_recursive_mutex_init_function(&test_mutex);
    EXPECT_EQ(result1, 0);
    
    mock_gthread_active = true;
    int result2 = __gthread_recursive_mutex_init_function(&test_mutex);
    EXPECT_EQ(result2, 0);
}

TEST_F(GThreadRecursiveMutexInitTest, ErrorCodeBoundaryValues) {
    // Test with maximum error code values
    mock_mutexattr_init_return = INT_MAX;
    int result = __gthread_recursive_mutex_init_function(&test_mutex);
    EXPECT_EQ(result, INT_MAX);
}

// Test Suite for Error Handling Scenarios
class GThreadRecursiveMutexInitErrorHandlingTest : public ::testing::Test {
protected:
    void SetUp() override {
        mock_gthread_active = true;
        mock_mutexattr_init_return = 0;
        mock_mutexattr_settype_return = 0;
        mock_mutex_init_return = 0;
        mock_mutexattr_destroy_return = 0;
    }

    __gthread_recursive_mutex_t test_mutex;
};

TEST_F(GThreadRecursiveMutexInitErrorHandlingTest, PartialInitializationFailure) {
    // Test that function handles partial initialization failure correctly
    mock_mutexattr_settype_return = ENOTSUP;
    
    int result = __gthread_recursive_mutex_init_function(&test_mutex);
    EXPECT_EQ(result, ENOTSUP);
}

TEST_F(GThreadRecursiveMutexInitErrorHandlingTest, CleanupAfterMutexInitFailure) {
    // Test that cleanup occurs even when mutex initialization fails
    mock_mutex_init_return = EAGAIN;
    
    int result = __gthread_recursive_mutex_init_function(&test_mutex);
    EXPECT_EQ(result, EAGAIN);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
