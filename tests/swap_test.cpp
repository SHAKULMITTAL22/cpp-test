// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <exception>
#include <stdexcept>
#include <memory>

// Test fixture for exception_ptr swap functionality
class ExceptionPtrSwapTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Create exception_ptr objects for testing
        try {
            throw std::runtime_error("Test exception 1");
        } catch (...) {
            ptr1 = std::current_exception();
        }
        
        try {
            throw std::invalid_argument("Test exception 2");
        } catch (...) {
            ptr2 = std::current_exception();
        }
        
        // Create null exception_ptr
        ptr_null = std::exception_ptr();
    }
    
    std::exception_ptr ptr1;
    std::exception_ptr ptr2;
    std::exception_ptr ptr_null;
};

// Test suite for exception_ptr swap method
TEST_F(ExceptionPtrSwapTest, SwapTwoValidExceptionPtrs) {
    // Store original states for verification
    std::exception_ptr original_ptr1 = ptr1;
    std::exception_ptr original_ptr2 = ptr2;
    
    // Perform swap operation
    ptr1.swap(ptr2);
    
    // Verify that the exception pointers have been swapped
    EXPECT_EQ(ptr1, original_ptr2);
    EXPECT_EQ(ptr2, original_ptr1);
    
    // Verify the actual exception content by rethrowing
    try {
        std::rethrow_exception(ptr1);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::invalid_argument& e) {
        EXPECT_STREQ(e.what(), "Test exception 2");
    }
    
    try {
        std::rethrow_exception(ptr2);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::runtime_error& e) {
        EXPECT_STREQ(e.what(), "Test exception 1");
    }
}

TEST_F(ExceptionPtrSwapTest, SwapValidWithNullExceptionPtr) {
    // Store original state for verification
    std::exception_ptr original_ptr1 = ptr1;
    
    // Perform swap operation between valid and null exception_ptr
    ptr1.swap(ptr_null);
    
    // Verify that ptr1 is now null and ptr_null contains the original exception
    EXPECT_EQ(ptr1, std::exception_ptr());
    EXPECT_EQ(ptr_null, original_ptr1);
    
    // Verify ptr1 is truly null
    EXPECT_FALSE(ptr1);
    
    // Verify ptr_null contains the original exception
    try {
        std::rethrow_exception(ptr_null);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::runtime_error& e) {
        EXPECT_STREQ(e.what(), "Test exception 1");
    }
}

TEST_F(ExceptionPtrSwapTest, SwapTwoNullExceptionPtrs) {
    std::exception_ptr null_ptr1;
    std::exception_ptr null_ptr2;
    
    // Perform swap operation between two null exception_ptrs
    null_ptr1.swap(null_ptr2);
    
    // Verify both remain null after swap
    EXPECT_EQ(null_ptr1, std::exception_ptr());
    EXPECT_EQ(null_ptr2, std::exception_ptr());
    EXPECT_FALSE(null_ptr1);
    EXPECT_FALSE(null_ptr2);
}

TEST_F(ExceptionPtrSwapTest, SwapSelfReference) {
    // Store original state for verification
    std::exception_ptr original_ptr1 = ptr1;
    
    // Perform self-swap operation
    ptr1.swap(ptr1);
    
    // Verify that self-swap doesn't change the exception_ptr
    EXPECT_EQ(ptr1, original_ptr1);
    
    // Verify the exception content remains unchanged
    try {
        std::rethrow_exception(ptr1);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::runtime_error& e) {
        EXPECT_STREQ(e.what(), "Test exception 1");
    }
}

TEST_F(ExceptionPtrSwapTest, SwapNoexceptGuarantee) {
    // Verify that swap operation is noexcept
    EXPECT_TRUE(noexcept(ptr1.swap(ptr2)));
    
    // Perform multiple swaps to ensure no exceptions are thrown
    EXPECT_NO_THROW({
        ptr1.swap(ptr2);
        ptr2.swap(ptr_null);
        ptr_null.swap(ptr1);
    });
}

TEST_F(ExceptionPtrSwapTest, SwapPreservesExceptionIdentity) {
    // Create two different exception types
    std::exception_ptr logic_error_ptr;
    std::exception_ptr domain_error_ptr;
    
    try {
        throw std::logic_error("Logic error test");
    } catch (...) {
        logic_error_ptr = std::current_exception();
    }
    
    try {
        throw std::domain_error("Domain error test");
    } catch (...) {
        domain_error_ptr = std::current_exception();
    }
    
    // Perform swap
    logic_error_ptr.swap(domain_error_ptr);
    
    // Verify exception types are preserved after swap
    try {
        std::rethrow_exception(logic_error_ptr);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::domain_error& e) {
        EXPECT_STREQ(e.what(), "Domain error test");
    }
    
    try {
        std::rethrow_exception(domain_error_ptr);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::logic_error& e) {
        EXPECT_STREQ(e.what(), "Logic error test");
    }
}

TEST_F(ExceptionPtrSwapTest, SwapAfterMultipleOperations) {
    // Create additional exception_ptr for complex scenario
    std::exception_ptr ptr3;
    try {
        throw std::overflow_error("Overflow test");
    } catch (...) {
        ptr3 = std::current_exception();
    }
    
    // Store original states
    std::exception_ptr original_ptr1 = ptr1;
    std::exception_ptr original_ptr3 = ptr3;
    
    // Perform multiple swap operations
    ptr1.swap(ptr_null);  // ptr1 becomes null, ptr_null gets original ptr1
    ptr3.swap(ptr_null);  // ptr3 becomes null, ptr_null gets original ptr3
    ptr1.swap(ptr3);      // Both are null, should remain null
    
    // Verify final states
    EXPECT_FALSE(ptr1);
    EXPECT_FALSE(ptr3);
    
    // Verify ptr_null contains the last swapped exception
    try {
        std::rethrow_exception(ptr_null);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::overflow_error& e) {
        EXPECT_STREQ(e.what(), "Overflow test");
    }
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
