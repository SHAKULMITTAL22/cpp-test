// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <pthread.h>
#include <cassert>
#include <cmath>
#include <iostream>

// Test fixture class for __gthread_setspecific tests
class GThreadSetSpecificTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Create a valid key for testing
        int result = pthread_key_create(&valid_key, nullptr);
        ASSERT_EQ(0, result) << "Failed to create pthread key for testing";
        
        // Create a key with destructor for cleanup testing
        result = pthread_key_create(&key_with_destructor, cleanup_function);
        ASSERT_EQ(0, result) << "Failed to create pthread key with destructor";
    }
    
    void TearDown() override {
        // Clean up created keys
        pthread_key_delete(valid_key);
        pthread_key_delete(key_with_destructor);
    }
    
    static void cleanup_function(void* ptr) {
        // Simple cleanup function for testing
        if (ptr) {
            // Cleanup logic would go here
        }
    }
    
    pthread_key_t valid_key;
    pthread_key_t key_with_destructor;
    static const pthread_key_t invalid_key = static_cast<pthread_key_t>(-1);
};

// Test Suite: Normal Operation Tests
TEST_F(GThreadSetSpecificTest, SetValidPointerWithValidKey_ReturnsSuccess) {
    int test_data = 42;
    void* test_ptr = &test_data;
    
    int result = __gthread_setspecific(valid_key, test_ptr);
    
    EXPECT_EQ(0, result) << "Setting valid pointer with valid key should succeed";
    
    // Verify the value was actually set
    void* retrieved_ptr = pthread_getspecific(valid_key);
    EXPECT_EQ(test_ptr, retrieved_ptr) << "Retrieved pointer should match the set pointer";
}

TEST_F(GThreadSetSpecificTest, SetNullPointerWithValidKey_ReturnsSuccess) {
    int result = __gthread_setspecific(valid_key, nullptr);
    
    EXPECT_EQ(0, result) << "Setting null pointer with valid key should succeed";
    
    // Verify the value was actually set to null
    void* retrieved_ptr = pthread_getspecific(valid_key);
    EXPECT_EQ(nullptr, retrieved_ptr) << "Retrieved pointer should be null";
}

TEST_F(GThreadSetSpecificTest, SetPointerWithKeyHavingDestructor_ReturnsSuccess) {
    int test_data = 100;
    void* test_ptr = &test_data;
    
    int result = __gthread_setspecific(key_with_destructor, test_ptr);
    
    EXPECT_EQ(0, result) << "Setting pointer with key having destructor should succeed";
    
    // Verify the value was actually set
    void* retrieved_ptr = pthread_getspecific(key_with_destructor);
    EXPECT_EQ(test_ptr, retrieved_ptr) << "Retrieved pointer should match the set pointer";
}

// Test Suite: Negative Test Cases
TEST_F(GThreadSetSpecificTest, SetPointerWithInvalidKey_ReturnsError) {
    int test_data = 42;
    void* test_ptr = &test_data;
    
    int result = __gthread_setspecific(invalid_key, test_ptr);
    
    EXPECT_NE(0, result) << "Setting pointer with invalid key should return error";
    EXPECT_EQ(EINVAL, result) << "Error code should be EINVAL for invalid key";
}

TEST_F(GThreadSetSpecificTest, SetPointerWithDeletedKey_ReturnsError) {
    // Create and immediately delete a key
    pthread_key_t temp_key;
    int create_result = pthread_key_create(&temp_key, nullptr);
    ASSERT_EQ(0, create_result) << "Failed to create temporary key";
    
    int delete_result = pthread_key_delete(temp_key);
    ASSERT_EQ(0, delete_result) << "Failed to delete temporary key";
    
    int test_data = 42;
    void* test_ptr = &test_data;
    
    int result = __gthread_setspecific(temp_key, test_ptr);
    
    EXPECT_NE(0, result) << "Setting pointer with deleted key should return error";
    EXPECT_EQ(EINVAL, result) << "Error code should be EINVAL for deleted key";
}

// Test Suite: Edge Case Tests
TEST_F(GThreadSetSpecificTest, OverwriteExistingValue_ReturnsSuccess) {
    int first_data = 42;
    int second_data = 84;
    void* first_ptr = &first_data;
    void* second_ptr = &second_data;
    
    // Set initial value
    int first_result = __gthread_setspecific(valid_key, first_ptr);
    EXPECT_EQ(0, first_result) << "First set operation should succeed";
    
    // Overwrite with new value
    int second_result = __gthread_setspecific(valid_key, second_ptr);
    EXPECT_EQ(0, second_result) << "Overwriting existing value should succeed";
    
    // Verify the new value is set
    void* retrieved_ptr = pthread_getspecific(valid_key);
    EXPECT_EQ(second_ptr, retrieved_ptr) << "Retrieved pointer should match the overwritten value";
    EXPECT_NE(first_ptr, retrieved_ptr) << "Retrieved pointer should not match the old value";
}

TEST_F(GThreadSetSpecificTest, SetSamePointerMultipleTimes_ReturnsSuccess) {
    int test_data = 42;
    void* test_ptr = &test_data;
    
    // Set the same pointer multiple times
    for (int i = 0; i < 5; ++i) {
        int result = __gthread_setspecific(valid_key, test_ptr);
        EXPECT_EQ(0, result) << "Setting same pointer multiple times should always succeed (iteration " << i << ")";
        
        // Verify the value remains consistent
        void* retrieved_ptr = pthread_getspecific(valid_key);
        EXPECT_EQ(test_ptr, retrieved_ptr) << "Retrieved pointer should remain consistent (iteration " << i << ")";
    }
}

TEST_F(GThreadSetSpecificTest, SetPointerWithMaximumKeyValue_HandlesGracefully) {
    // Test with a key value that might be at the boundary
    pthread_key_t boundary_key = PTHREAD_KEYS_MAX;
    int test_data = 42;
    void* test_ptr = &test_data;
    
    int result = __gthread_setspecific(boundary_key, test_ptr);
    
    // This should fail gracefully with an appropriate error code
    EXPECT_NE(0, result) << "Setting pointer with boundary key value should handle gracefully";
}

// Main function to run all tests
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
