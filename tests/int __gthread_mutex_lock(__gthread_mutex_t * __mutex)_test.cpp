// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <pthread.h>
#include <cassert>
#include <cmath>
#include <iostream>

// Mock declarations for testing purposes
extern "C" {
    // Mock function declarations
    int __gthread_active_p();
    int pthread_mutex_lock(pthread_mutex_t* mutex);
    
    // Function under test declaration
    int __gthread_mutex_lock(pthread_mutex_t* __mutex);
}

// Mock implementations for controlled testing
namespace {
    bool mock_gthread_active = true;
    int mock_pthread_lock_return = 0;
    pthread_mutex_t* last_mutex_passed = nullptr;
    
    // Mock function to control thread activity state
    void set_gthread_active(bool active) {
        mock_gthread_active = active;
    }
    
    // Mock function to control pthread_mutex_lock return value
    void set_pthread_lock_return(int return_value) {
        mock_pthread_lock_return = return_value;
    }
}

// Mock implementations
extern "C" {
    int __gthread_active_p() {
        return mock_gthread_active ? 1 : 0;
    }
    
    int pthread_mutex_lock(pthread_mutex_t* mutex) {
        last_mutex_passed = mutex;
        return mock_pthread_lock_return;
    }
}

// Test Suite for __gthread_mutex_lock function
class GThreadMutexLockTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Reset mock state before each test
        set_gthread_active(true);
        set_pthread_lock_return(0);
        last_mutex_passed = nullptr;
        
        // Initialize test mutex
        pthread_mutex_init(&test_mutex, nullptr);
    }
    
    void TearDown() override {
        // Clean up test mutex
        pthread_mutex_destroy(&test_mutex);
    }
    
    pthread_mutex_t test_mutex;
};

// Positive Test Cases
TEST_F(GThreadMutexLockTest, SuccessfulLockWhenThreadsActive) {
    // Arrange
    set_gthread_active(true);
    set_pthread_lock_return(0);
    
    // Act
    int result = __gthread_mutex_lock(&test_mutex);
    
    // Assert
    EXPECT_EQ(result, 0);
    EXPECT_EQ(last_mutex_passed, &test_mutex);
}

TEST_F(GThreadMutexLockTest, SuccessfulReturnWhenThreadsInactive) {
    // Arrange
    set_gthread_active(false);
    
    // Act
    int result = __gthread_mutex_lock(&test_mutex);
    
    // Assert
    EXPECT_EQ(result, 0);
    EXPECT_EQ(last_mutex_passed, nullptr); // pthread_mutex_lock should not be called
}

// Negative Test Cases
TEST_F(GThreadMutexLockTest, PthreadLockFailureWhenThreadsActive) {
    // Arrange
    set_gthread_active(true);
    set_pthread_lock_return(EINVAL); // Simulate pthread_mutex_lock failure
    
    // Act
    int result = __gthread_mutex_lock(&test_mutex);
    
    // Assert
    EXPECT_EQ(result, EINVAL);
    EXPECT_EQ(last_mutex_passed, &test_mutex);
}

TEST_F(GThreadMutexLockTest, PthreadLockDeadlockErrorWhenThreadsActive) {
    // Arrange
    set_gthread_active(true);
    set_pthread_lock_return(EDEADLK); // Simulate deadlock error
    
    // Act
    int result = __gthread_mutex_lock(&test_mutex);
    
    // Assert
    EXPECT_EQ(result, EDEADLK);
    EXPECT_EQ(last_mutex_passed, &test_mutex);
}

// Edge Case Tests
TEST_F(GThreadMutexLockTest, NullMutexPointerWhenThreadsActive) {
    // Arrange
    set_gthread_active(true);
    set_pthread_lock_return(EINVAL); // Expected behavior for null pointer
    
    // Act
    int result = __gthread_mutex_lock(nullptr);
    
    // Assert
    EXPECT_EQ(result, EINVAL);
    EXPECT_EQ(last_mutex_passed, nullptr);
}

TEST_F(GThreadMutexLockTest, NullMutexPointerWhenThreadsInactive) {
    // Arrange
    set_gthread_active(false);
    
    // Act
    int result = __gthread_mutex_lock(nullptr);
    
    // Assert
    EXPECT_EQ(result, 0); // Should return 0 regardless when threads inactive
    EXPECT_EQ(last_mutex_passed, nullptr);
}

// Additional Test Cases for comprehensive coverage
TEST_F(GThreadMutexLockTest, MultipleConsecutiveCallsWhenThreadsActive) {
    // Arrange
    set_gthread_active(true);
    set_pthread_lock_return(0);
    
    // Act & Assert - Multiple calls should work consistently
    for (int i = 0; i < 3; ++i) {
        int result = __gthread_mutex_lock(&test_mutex);
        EXPECT_EQ(result, 0);
        EXPECT_EQ(last_mutex_passed, &test_mutex);
    }
}

TEST_F(GThreadMutexLockTest, ThreadStateToggleBehavior) {
    // Test behavior when thread state changes between calls
    
    // First call with threads active
    set_gthread_active(true);
    set_pthread_lock_return(0);
    int result1 = __gthread_mutex_lock(&test_mutex);
    EXPECT_EQ(result1, 0);
    EXPECT_EQ(last_mutex_passed, &test_mutex);
    
    // Reset last_mutex_passed for next test
    last_mutex_passed = nullptr;
    
    // Second call with threads inactive
    set_gthread_active(false);
    int result2 = __gthread_mutex_lock(&test_mutex);
    EXPECT_EQ(result2, 0);
    EXPECT_EQ(last_mutex_passed, nullptr); // pthread_mutex_lock should not be called
}

// Test Suite for boundary conditions
class GThreadMutexLockBoundaryTest : public ::testing::Test {
protected:
    void SetUp() override {
        set_gthread_active(true);
        set_pthread_lock_return(0);
        last_mutex_passed = nullptr;
    }
};

TEST_F(GThreadMutexLockBoundaryTest, MaxErrorCodeReturn) {
    // Arrange
    set_gthread_active(true);
    set_pthread_lock_return(INT_MAX); // Maximum possible error code
    pthread_mutex_t test_mutex;
    pthread_mutex_init(&test_mutex, nullptr);
    
    // Act
    int result = __gthread_mutex_lock(&test_mutex);
    
    // Assert
    EXPECT_EQ(result, INT_MAX);
    EXPECT_EQ(last_mutex_passed, &test_mutex);
    
    // Cleanup
    pthread_mutex_destroy(&test_mutex);
}

TEST_F(GThreadMutexLockBoundaryTest, MinErrorCodeReturn) {
    // Arrange
    set_gthread_active(true);
    set_pthread_lock_return(INT_MIN); // Minimum possible error code
    pthread_mutex_t test_mutex;
    pthread_mutex_init(&test_mutex, nullptr);
    
    // Act
    int result = __gthread_mutex_lock(&test_mutex);
    
    // Assert
    EXPECT_EQ(result, INT_MIN);
    EXPECT_EQ(last_mutex_passed, &test_mutex);
    
    // Cleanup
    pthread_mutex_destroy(&test_mutex);
}

int main(int argc, char** argv) {
    // Initialize Google Test framework
    ::testing::InitGoogleTest(&argc, argv);
    
    // Run all test cases
    return RUN_ALL_TESTS();
}
