// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>

// Test suite for __gthread_active_p function
class GThreadActivePTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup code if needed
    }
    
    void TearDown() override {
        // Cleanup code if needed
    }
};

// Positive test cases
TEST_F(GThreadActivePTest, ReturnsOneOnFirstCall) {
    // Test that the function returns 1 on first call
    int result = __gthread_active_p();
    EXPECT_EQ(1, result);
}

TEST_F(GThreadActivePTest, ReturnsOneOnSubsequentCalls) {
    // Test that the function consistently returns 1 on multiple calls
    int first_call = __gthread_active_p();
    int second_call = __gthread_active_p();
    int third_call = __gthread_active_p();
    
    EXPECT_EQ(1, first_call);
    EXPECT_EQ(1, second_call);
    EXPECT_EQ(1, third_call);
}

// Negative test cases
TEST_F(GThreadActivePTest, DoesNotReturnZero) {
    // Test that the function never returns 0
    int result = __gthread_active_p();
    EXPECT_NE(0, result);
}

TEST_F(GThreadActivePTest, DoesNotReturnNegativeValue) {
    // Test that the function never returns a negative value
    int result = __gthread_active_p();
    EXPECT_GE(result, 0);
}

// Edge case test
TEST_F(GThreadActivePTest, ConsistentBehaviorInLoop) {
    // Test that the function maintains consistent behavior when called multiple times in a loop
    const int num_iterations = 1000;
    
    for (int i = 0; i < num_iterations; ++i) {
        int result = __gthread_active_p();
        EXPECT_EQ(1, result) << "Function returned unexpected value at iteration " << i;
    }
}

// Additional test for function signature and return type
TEST_F(GThreadActivePTest, ReturnTypeIsInteger) {
    // Test that the function returns an integer type
    auto result = __gthread_active_p();
    EXPECT_TRUE(std::is_same_v<decltype(result), int>);
    EXPECT_EQ(1, result);
}

// Test for thread safety (basic test)
TEST_F(GThreadActivePTest, BasicThreadSafetyTest) {
    // Test that the function can be called safely (basic check)
    // Since the function is simple and stateless, this should always pass
    std::vector<int> results;
    const int num_calls = 10;
    
    for (int i = 0; i < num_calls; ++i) {
        results.push_back(__gthread_active_p());
    }
    
    // Verify all calls returned 1
    for (const auto& result : results) {
        EXPECT_EQ(1, result);
    }
}

// Performance test (basic)
TEST_F(GThreadActivePTest, FunctionExecutesQuickly) {
    // Test that the function executes without significant delay
    auto start = std::chrono::high_resolution_clock::now();
    
    int result = __gthread_active_p();
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    EXPECT_EQ(1, result);
    // Function should execute very quickly (less than 1ms)
    EXPECT_LT(duration.count(), 1000);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
