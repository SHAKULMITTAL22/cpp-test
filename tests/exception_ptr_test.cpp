// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <exception>
#include <stdexcept>
#include <memory>

// Test fixture for exception_ptr move constructor tests
class ExceptionPtrMoveConstructorTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Create test exceptions for use in tests
        try {
            throw std::runtime_error("Test runtime error");
        } catch (...) {
            valid_exception_ptr = std::current_exception();
        }
        
        try {
            throw std::invalid_argument("Test invalid argument");
        } catch (...) {
            another_exception_ptr = std::current_exception();
        }
    }
    
    void TearDown() override {
        // Clean up resources if needed
    }
    
    std::exception_ptr valid_exception_ptr;
    std::exception_ptr another_exception_ptr;
};

// Positive Test Case 1: Move constructor with valid exception_ptr
TEST_F(ExceptionPtrMoveConstructorTest, MoveConstructorWithValidExceptionPtr) {
    // Create a copy to move from
    std::exception_ptr source_ptr = valid_exception_ptr;
    
    // Verify source has an exception before move
    EXPECT_NE(source_ptr, nullptr);
    
    // Perform move construction
    std::exception_ptr moved_ptr(std::move(source_ptr));
    
    // Verify the moved-to object contains the exception
    EXPECT_NE(moved_ptr, nullptr);
    
    // Verify the moved-from object is now null
    EXPECT_EQ(source_ptr, nullptr);
    
    // Verify the exception can still be rethrown from moved object
    EXPECT_NO_THROW({
        try {
            std::rethrow_exception(moved_ptr);
        } catch (const std::runtime_error& e) {
            EXPECT_STREQ(e.what(), "Test runtime error");
        }
    });
}

// Positive Test Case 2: Move constructor preserves exception type and message
TEST_F(ExceptionPtrMoveConstructorTest, MoveConstructorPreservesExceptionDetails) {
    std::exception_ptr source_ptr = another_exception_ptr;
    
    // Move construct
    std::exception_ptr moved_ptr(std::move(source_ptr));
    
    // Verify exception details are preserved
    try {
        std::rethrow_exception(moved_ptr);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::invalid_argument& e) {
        EXPECT_STREQ(e.what(), "Test invalid argument");
    } catch (...) {
        FAIL() << "Wrong exception type caught";
    }
}

// Negative Test Case 1: Move constructor with null exception_ptr
TEST_F(ExceptionPtrMoveConstructorTest, MoveConstructorWithNullExceptionPtr) {
    std::exception_ptr null_source_ptr;
    
    // Verify source is null
    EXPECT_EQ(null_source_ptr, nullptr);
    
    // Move construct from null pointer
    std::exception_ptr moved_ptr(std::move(null_source_ptr));
    
    // Verify both pointers are null
    EXPECT_EQ(moved_ptr, nullptr);
    EXPECT_EQ(null_source_ptr, nullptr);
}

// Negative Test Case 2: Move constructor with already moved-from exception_ptr
TEST_F(ExceptionPtrMoveConstructorTest, MoveConstructorWithAlreadyMovedFromPtr) {
    std::exception_ptr source_ptr = valid_exception_ptr;
    
    // First move
    std::exception_ptr first_moved_ptr(std::move(source_ptr));
    EXPECT_EQ(source_ptr, nullptr);
    EXPECT_NE(first_moved_ptr, nullptr);
    
    // Second move from already moved-from object
    std::exception_ptr second_moved_ptr(std::move(source_ptr));
    
    // Verify second move results in null pointer
    EXPECT_EQ(second_moved_ptr, nullptr);
    EXPECT_EQ(source_ptr, nullptr);
}

// Edge Case Test: Self-move scenario prevention
TEST_F(ExceptionPtrMoveConstructorTest, MoveConstructorSelfMoveScenario) {
    std::exception_ptr source_ptr = valid_exception_ptr;
    std::exception_ptr* ptr_address = &source_ptr;
    
    // Simulate potential self-move scenario by creating reference
    std::exception_ptr& source_ref = source_ptr;
    
    // Move construct (this tests the noexcept guarantee)
    EXPECT_NO_THROW({
        std::exception_ptr moved_ptr(std::move(source_ref));
        // Verify the operation completed
        EXPECT_EQ(source_ptr, nullptr);
        EXPECT_NE(moved_ptr, nullptr);
    });
}

// Test for noexcept guarantee
TEST_F(ExceptionPtrMoveConstructorTest, MoveConstructorIsNoexcept) {
    // Verify that the move constructor is marked noexcept
    EXPECT_TRUE(std::is_nothrow_move_constructible_v<std::exception_ptr>);
}

// Test multiple consecutive moves
TEST_F(ExceptionPtrMoveConstructorTest, ConsecutiveMoveOperations) {
    std::exception_ptr ptr1 = valid_exception_ptr;
    
    // Chain of moves
    std::exception_ptr ptr2(std::move(ptr1));
    std::exception_ptr ptr3(std::move(ptr2));
    std::exception_ptr ptr4(std::move(ptr3));
    
    // Verify only the final pointer has the exception
    EXPECT_EQ(ptr1, nullptr);
    EXPECT_EQ(ptr2, nullptr);
    EXPECT_EQ(ptr3, nullptr);
    EXPECT_NE(ptr4, nullptr);
    
    // Verify exception is still valid
    try {
        std::rethrow_exception(ptr4);
        FAIL() << "Expected exception to be thrown";
    } catch (const std::runtime_error& e) {
        EXPECT_STREQ(e.what(), "Test runtime error");
    }
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
