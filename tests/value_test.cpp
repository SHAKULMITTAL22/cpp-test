// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <system_error>
#include <cassert>
#include <cmath>
#include <iostream>

// Test fixture for std::error_condition::value() method
class ErrorConditionValueTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup common test data
    }

    void TearDown() override {
        // Cleanup after tests
    }
};

// Test suite for std::error_condition::value() method
TEST_F(ErrorConditionValueTest, DefaultConstructedErrorCondition_ReturnsZero) {
    // Test that a default-constructed error_condition returns 0
    std::error_condition ec;
    EXPECT_EQ(0, ec.value());
}

TEST_F(ErrorConditionValueTest, ConstructedWithPositiveValue_ReturnsCorrectValue) {
    // Test that error_condition constructed with positive value returns that value
    const int expected_value = 42;
    std::error_condition ec(expected_value, std::generic_category());
    EXPECT_EQ(expected_value, ec.value());
}

TEST_F(ErrorConditionValueTest, ConstructedWithLargePositiveValue_ReturnsCorrectValue) {
    // Test with large positive integer value
    const int expected_value = 2147483647; // INT_MAX
    std::error_condition ec(expected_value, std::generic_category());
    EXPECT_EQ(expected_value, ec.value());
}

TEST_F(ErrorConditionValueTest, ConstructedWithNegativeValue_ReturnsCorrectValue) {
    // Test that error_condition can handle negative values
    const int expected_value = -1;
    std::error_condition ec(expected_value, std::generic_category());
    EXPECT_EQ(expected_value, ec.value());
}

TEST_F(ErrorConditionValueTest, ConstructedWithLargeNegativeValue_ReturnsCorrectValue) {
    // Test with large negative integer value
    const int expected_value = -2147483648; // INT_MIN
    std::error_condition ec(expected_value, std::generic_category());
    EXPECT_EQ(expected_value, ec.value());
}

TEST_F(ErrorConditionValueTest, EdgeCase_ZeroValue_ReturnsZero) {
    // Edge case: explicitly constructed with zero value
    const int expected_value = 0;
    std::error_condition ec(expected_value, std::generic_category());
    EXPECT_EQ(expected_value, ec.value());
}

TEST_F(ErrorConditionValueTest, CopyConstructedErrorCondition_RetainsSameValue) {
    // Test that copy construction preserves the value
    const int expected_value = 123;
    std::error_condition original(expected_value, std::generic_category());
    std::error_condition copy(original);
    EXPECT_EQ(expected_value, copy.value());
    EXPECT_EQ(original.value(), copy.value());
}

TEST_F(ErrorConditionValueTest, AssignedErrorCondition_RetainsSameValue) {
    // Test that assignment preserves the value
    const int expected_value = 456;
    std::error_condition original(expected_value, std::generic_category());
    std::error_condition assigned;
    assigned = original;
    EXPECT_EQ(expected_value, assigned.value());
    EXPECT_EQ(original.value(), assigned.value());
}

TEST_F(ErrorConditionValueTest, MultipleCallsToValue_ReturnConsistentResults) {
    // Test that multiple calls to value() return consistent results
    const int expected_value = 789;
    std::error_condition ec(expected_value, std::generic_category());
    
    // Call value() multiple times and verify consistency
    EXPECT_EQ(expected_value, ec.value());
    EXPECT_EQ(expected_value, ec.value());
    EXPECT_EQ(expected_value, ec.value());
}

TEST_F(ErrorConditionValueTest, ConstErrorCondition_ValueAccessible) {
    // Test that value() can be called on const error_condition objects
    const int expected_value = 999;
    const std::error_condition ec(expected_value, std::generic_category());
    EXPECT_EQ(expected_value, ec.value());
}

// Test with different error categories to ensure value is independent of category
TEST_F(ErrorConditionValueTest, DifferentCategories_SameValueReturned) {
    const int expected_value = 100;
    
    std::error_condition ec1(expected_value, std::generic_category());
    std::error_condition ec2(expected_value, std::system_category());
    
    EXPECT_EQ(expected_value, ec1.value());
    EXPECT_EQ(expected_value, ec2.value());
    EXPECT_EQ(ec1.value(), ec2.value());
}

// Test noexcept specification compliance
TEST_F(ErrorConditionValueTest, NoexceptSpecification_DoesNotThrow) {
    // Test that value() method is noexcept and doesn't throw
    std::error_condition ec(42, std::generic_category());
    
    // This test verifies the noexcept specification
    EXPECT_NO_THROW({
        int val = ec.value();
        (void)val; // Suppress unused variable warning
    });
}

int main(int argc, char** argv) {
    // Initialize Google Test framework
    ::testing::InitGoogleTest(&argc, argv);
    
    // Run all test cases
    return RUN_ALL_TESTS();
}
