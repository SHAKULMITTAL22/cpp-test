// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <pthread.h>
#include <time.h>
#include <errno.h>
#include <chrono>
#include <thread>

// Forward declaration of the function under test
extern "C" {
    int __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t* __mutex, 
                                          const __gthread_time_t* __abs_timeout);
}

// Test fixture for recursive mutex timedlock tests
class GThreadRecursiveMutexTimedlockTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Initialize recursive mutex
        pthread_mutexattr_init(&mutex_attr);
        pthread_mutexattr_settype(&mutex_attr, PTHREAD_MUTEX_RECURSIVE);
        pthread_mutex_init(&recursive_mutex, &mutex_attr);
        
        // Set up timeout structures
        clock_gettime(CLOCK_REALTIME, &future_timeout);
        future_timeout.tv_sec += 1; // 1 second in the future
        
        clock_gettime(CLOCK_REALTIME, &past_timeout);
        past_timeout.tv_sec -= 1; // 1 second in the past
    }
    
    void TearDown() override {
        pthread_mutex_destroy(&recursive_mutex);
        pthread_mutexattr_destroy(&mutex_attr);
    }
    
    pthread_mutex_t recursive_mutex;
    pthread_mutexattr_t mutex_attr;
    struct timespec future_timeout;
    struct timespec past_timeout;
};

// Test Suite: Normal Operation Tests
TEST_F(GThreadRecursiveMutexTimedlockTest, SuccessfulLockWithValidTimeout) {
    // Test successful lock acquisition with valid future timeout
    int result = __gthread_recursive_mutex_timedlock(&recursive_mutex, &future_timeout);
    EXPECT_EQ(result, 0) << "Should successfully acquire lock with valid timeout";
    
    // Clean up - unlock the mutex
    pthread_mutex_unlock(&recursive_mutex);
}

TEST_F(GThreadRecursiveMutexTimedlockTest, RecursiveLockSameMutex) {
    // Test recursive locking of the same mutex (should succeed)
    int first_lock = __gthread_recursive_mutex_timedlock(&recursive_mutex, &future_timeout);
    EXPECT_EQ(first_lock, 0) << "First lock should succeed";
    
    int second_lock = __gthread_recursive_mutex_timedlock(&recursive_mutex, &future_timeout);
    EXPECT_EQ(second_lock, 0) << "Recursive lock should succeed";
    
    // Clean up - unlock twice
    pthread_mutex_unlock(&recursive_mutex);
    pthread_mutex_unlock(&recursive_mutex);
}

// Test Suite: Negative Test Cases
TEST_F(GThreadRecursiveMutexTimedlockTest, NullMutexPointer) {
    // Test with null mutex pointer
    int result = __gthread_recursive_mutex_timedlock(nullptr, &future_timeout);
    EXPECT_NE(result, 0) << "Should fail with null mutex pointer";
}

TEST_F(GThreadRecursiveMutexTimedlockTest, NullTimeoutPointer) {
    // Test with null timeout pointer
    int result = __gthread_recursive_mutex_timedlock(&recursive_mutex, nullptr);
    EXPECT_NE(result, 0) << "Should fail with null timeout pointer";
}

// Test Suite: Edge Case Tests
TEST_F(GThreadRecursiveMutexTimedlockTest, ExpiredTimeout) {
    // First, lock the mutex from another thread to make it unavailable
    std::thread lock_holder([this]() {
        pthread_mutex_lock(&recursive_mutex);
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        pthread_mutex_unlock(&recursive_mutex);
    });
    
    // Give the thread time to acquire the lock
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    // Try to lock with past timeout (should fail with timeout)
    int result = __gthread_recursive_mutex_timedlock(&recursive_mutex, &past_timeout);
    EXPECT_EQ(result, ETIMEDOUT) << "Should timeout with expired timeout";
    
    lock_holder.join();
}

TEST_F(GThreadRecursiveMutexTimedlockTest, ZeroTimeout) {
    // Test with zero timeout (immediate timeout)
    struct timespec zero_timeout = {0, 0};
    
    // First lock the mutex to make it unavailable
    pthread_mutex_lock(&recursive_mutex);
    
    int result = __gthread_recursive_mutex_timedlock(&recursive_mutex, &zero_timeout);
    EXPECT_EQ(result, ETIMEDOUT) << "Should immediately timeout with zero timeout";
    
    // Clean up
    pthread_mutex_unlock(&recursive_mutex);
}

TEST_F(GThreadRecursiveMutexTimedlockTest, InvalidTimeoutValue) {
    // Test with invalid timeout value (negative nanoseconds)
    struct timespec invalid_timeout;
    clock_gettime(CLOCK_REALTIME, &invalid_timeout);
    invalid_timeout.tv_nsec = -1; // Invalid nanoseconds value
    
    int result = __gthread_recursive_mutex_timedlock(&recursive_mutex, &invalid_timeout);
    EXPECT_EQ(result, EINVAL) << "Should fail with invalid timeout value";
}

// Test Suite: Boundary Condition Tests
TEST_F(GThreadRecursiveMutexTimedlockTest, MaximumValidTimeout) {
    // Test with maximum valid timeout value
    struct timespec max_timeout;
    max_timeout.tv_sec = LONG_MAX;
    max_timeout.tv_nsec = 999999999; // Maximum valid nanoseconds
    
    int result = __gthread_recursive_mutex_timedlock(&recursive_mutex, &max_timeout);
    EXPECT_EQ(result, 0) << "Should succeed with maximum valid timeout";
    
    // Clean up
    pthread_mutex_unlock(&recursive_mutex);
}

TEST_F(GThreadRecursiveMutexTimedlockTest, ConcurrentAccessWithTimeout) {
    // Test concurrent access with timeout from multiple threads
    const int num_threads = 3;
    std::vector<std::thread> threads;
    std::vector<int> results(num_threads);
    
    for (int i = 0; i < num_threads; ++i) {
        threads.emplace_back([this, i, &results]() {
            struct timespec thread_timeout;
            clock_gettime(CLOCK_REALTIME, &thread_timeout);
            thread_timeout.tv_sec += 2; // 2 seconds timeout
            
            results[i] = __gthread_recursive_mutex_timedlock(&recursive_mutex, &thread_timeout);
            
            if (results[i] == 0) {
                // Hold the lock briefly
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                pthread_mutex_unlock(&recursive_mutex);
            }
        });
    }
    
    // Wait for all threads to complete
    for (auto& thread : threads) {
        thread.join();
    }
    
    // At least one thread should succeed
    bool at_least_one_success = false;
    for (int result : results) {
        if (result == 0) {
            at_least_one_success = true;
            break;
        }
    }
    EXPECT_TRUE(at_least_one_success) << "At least one thread should successfully acquire the lock";
}

// Main function to run all tests
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
