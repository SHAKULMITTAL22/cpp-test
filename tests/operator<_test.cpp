// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <system_error>
#include <memory>

// Test fixture for error_category operator< tests
class ErrorCategoryOperatorLessTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Create instances of different error categories for testing
        generic_cat = &std::generic_category();
        system_cat = &std::system_category();
    }

    const std::error_category* generic_cat;
    const std::error_category* system_cat;
};

// Test suite for error_category operator< functionality
TEST_F(ErrorCategoryOperatorLessTest, SameCategoryComparison_ReturnsFalse) {
    // Test that comparing a category with itself returns false
    EXPECT_FALSE(*generic_cat < *generic_cat);
    EXPECT_FALSE(*system_cat < *system_cat);
}

TEST_F(ErrorCategoryOperatorLessTest, DifferentCategoriesComparison_ReturnsConsistentResult) {
    // Test that comparison between different categories is consistent
    bool result1 = *generic_cat < *system_cat;
    bool result2 = *system_cat < *generic_cat;
    
    // One should be true, the other false (strict weak ordering)
    EXPECT_NE(result1, result2);
    
    // Test consistency - multiple calls should return same result
    EXPECT_EQ(result1, *generic_cat < *system_cat);
    EXPECT_EQ(result2, *system_cat < *generic_cat);
}

TEST_F(ErrorCategoryOperatorLessTest, TransitivityProperty_MaintainsStrictWeakOrdering) {
    // Create a third category for transitivity testing
    const std::error_category& future_cat = std::future_category();
    
    // Test transitivity: if a < b and b < c, then a < c
    bool generic_less_system = *generic_cat < *system_cat;
    bool system_less_future = *system_cat < future_cat;
    bool generic_less_future = *generic_cat < future_cat;
    
    if (generic_less_system && system_less_future) {
        EXPECT_TRUE(generic_less_future);
    }
    
    // Test that the relation is irreflexive
    EXPECT_FALSE(*generic_cat < *generic_cat);
    EXPECT_FALSE(*system_cat < *system_cat);
    EXPECT_FALSE(future_cat < future_cat);
}

TEST_F(ErrorCategoryOperatorLessTest, NoexceptSpecification_DoesNotThrow) {
    // Test that the operator< is noexcept and doesn't throw exceptions
    EXPECT_NO_THROW({
        bool result = *generic_cat < *system_cat;
        (void)result; // Suppress unused variable warning
    });
    
    EXPECT_NO_THROW({
        bool result = *system_cat < *generic_cat;
        (void)result; // Suppress unused variable warning
    });
}

TEST_F(ErrorCategoryOperatorLessTest, PointerBasedComparison_ReflectsMemoryAddresses) {
    // Test that the comparison is based on pointer addresses
    // This test verifies the underlying implementation using less<const error_category*>
    
    const std::error_category* cat1 = generic_cat;
    const std::error_category* cat2 = system_cat;
    
    bool operator_result = *cat1 < *cat2;
    bool pointer_result = std::less<const std::error_category*>()(cat1, cat2);
    
    // The operator< should behave the same as direct pointer comparison
    EXPECT_EQ(operator_result, pointer_result);
}

// Edge case: Test with custom error category
class CustomErrorCategory : public std::error_category {
public:
    const char* name() const noexcept override {
        return "custom_error";
    }
    
    std::string message(int condition) const override {
        return "Custom error message";
    }
};

TEST_F(ErrorCategoryOperatorLessTest, CustomCategoryComparison_WorksCorrectly) {
    CustomErrorCategory custom_cat;
    
    // Test comparison with standard categories
    bool custom_less_generic = custom_cat < *generic_cat;
    bool generic_less_custom = *generic_cat < custom_cat;
    
    // Ensure asymmetric property
    EXPECT_NE(custom_less_generic, generic_less_custom);
    
    // Test self-comparison
    EXPECT_FALSE(custom_cat < custom_cat);
}

TEST_F(ErrorCategoryOperatorLessTest, MultipleInstancesComparison_MaintainsConsistency) {
    // Test that multiple instances of the same category type compare correctly
    CustomErrorCategory custom1;
    CustomErrorCategory custom2;
    
    // Different instances should have consistent comparison
    bool result1 = custom1 < custom2;
    bool result2 = custom2 < custom1;
    
    // Should maintain strict weak ordering
    EXPECT_NE(result1, result2);
    
    // Self comparison should always be false
    EXPECT_FALSE(custom1 < custom1);
    EXPECT_FALSE(custom2 < custom2);
}

// Negative test case: Verify behavior with null-like scenarios isn't applicable
// since operator< works with references, not pointers directly
TEST_F(ErrorCategoryOperatorLessTest, ReferenceComparison_AlwaysValid) {
    // Since we're dealing with references, we can't have null references
    // This test ensures that any valid error_category reference works
    const std::error_category& ref1 = std::generic_category();
    const std::error_category& ref2 = std::system_category();
    
    // These operations should always be valid
    EXPECT_NO_THROW({
        bool result = ref1 < ref2;
        (void)result;
    });
    
    EXPECT_NO_THROW({
        bool result = ref2 < ref1;
        (void)result;
    });
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
