// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <cmath>
#include <limits>

// Test suite for __isgreaterequalf function
class IsGreaterEqualfTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

// Positive test cases
TEST_F(IsGreaterEqualfTest, PositiveCase_GreaterValue) {
    float_t x = 5.5f;
    float_t y = 3.2f;
    EXPECT_EQ(__isgreaterequalf(x, y), 1);
}

TEST_F(IsGreaterEqualfTest, PositiveCase_EqualValues) {
    float_t x = 4.7f;
    float_t y = 4.7f;
    EXPECT_EQ(__isgreaterequalf(x, y), 1);
}

// Negative test cases
TEST_F(IsGreaterEqualfTest, NegativeCase_SmallerValue) {
    float_t x = 2.1f;
    float_t y = 8.9f;
    EXPECT_EQ(__isgreaterequalf(x, y), 0);
}

TEST_F(IsGreaterEqualfTest, NegativeCase_NegativeNumbers) {
    float_t x = -10.5f;
    float_t y = -3.2f;
    EXPECT_EQ(__isgreaterequalf(x, y), 0);
}

// Edge case tests
TEST_F(IsGreaterEqualfTest, EdgeCase_ZeroValues) {
    float_t x = 0.0f;
    float_t y = 0.0f;
    EXPECT_EQ(__isgreaterequalf(x, y), 1);
}

TEST_F(IsGreaterEqualfTest, EdgeCase_PositiveZeroVsNegativeZero) {
    float_t x = +0.0f;
    float_t y = -0.0f;
    EXPECT_EQ(__isgreaterequalf(x, y), 1);
}

TEST_F(IsGreaterEqualfTest, EdgeCase_InfinityValues) {
    float_t x = std::numeric_limits<float_t>::infinity();
    float_t y = 100.0f;
    EXPECT_EQ(__isgreaterequalf(x, y), 1);
}

TEST_F(IsGreaterEqualfTest, EdgeCase_NegativeInfinity) {
    float_t x = -std::numeric_limits<float_t>::infinity();
    float_t y = -100.0f;
    EXPECT_EQ(__isgreaterequalf(x, y), 0);
}

TEST_F(IsGreaterEqualfTest, EdgeCase_MaxFloatValues) {
    float_t x = std::numeric_limits<float_t>::max();
    float_t y = std::numeric_limits<float_t>::max();
    EXPECT_EQ(__isgreaterequalf(x, y), 1);
}

TEST_F(IsGreaterEqualfTest, EdgeCase_MinFloatValues) {
    float_t x = std::numeric_limits<float_t>::min();
    float_t y = std::numeric_limits<float_t>::min();
    EXPECT_EQ(__isgreaterequalf(x, y), 1);
}

// NaN handling tests
TEST_F(IsGreaterEqualfTest, NaNCase_FirstArgumentNaN) {
    float_t x = std::numeric_limits<float_t>::quiet_NaN();
    float_t y = 5.0f;
    EXPECT_EQ(__isgreaterequalf(x, y), 0);
}

TEST_F(IsGreaterEqualfTest, NaNCase_SecondArgumentNaN) {
    float_t x = 5.0f;
    float_t y = std::numeric_limits<float_t>::quiet_NaN();
    EXPECT_EQ(__isgreaterequalf(x, y), 0);
}

TEST_F(IsGreaterEqualfTest, NaNCase_BothArgumentsNaN) {
    float_t x = std::numeric_limits<float_t>::quiet_NaN();
    float_t y = std::numeric_limits<float_t>::quiet_NaN();
    EXPECT_EQ(__isgreaterequalf(x, y), 0);
}

// Additional boundary tests
TEST_F(IsGreaterEqualfTest, BoundaryCase_VerySmallDifference) {
    float_t x = 1.0f + std::numeric_limits<float_t>::epsilon();
    float_t y = 1.0f;
    EXPECT_EQ(__isgreaterequalf(x, y), 1);
}

TEST_F(IsGreaterEqualfTest, BoundaryCase_NegativeAndPositive) {
    float_t x = 0.1f;
    float_t y = -0.1f;
    EXPECT_EQ(__isgreaterequalf(x, y), 1);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
