// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <pthread.h>
#include <cassert>
#include <cmath>
#include <iostream>

// Mock definitions for testing purposes
typedef pthread_once_t __gthread_once_t;

// Mock function to simulate __gthread_active_p behavior
static bool mock_gthread_active = true;
static bool mock_pthread_once_success = true;
static int mock_pthread_once_call_count = 0;

// Mock implementation of __gthread_active_p
extern "C" int __gthread_active_p() {
    return mock_gthread_active ? 1 : 0;
}

// Mock implementation of pthread_once
extern "C" int pthread_once(pthread_once_t *once_control, void (*init_routine)(void)) {
    mock_pthread_once_call_count++;
    if (mock_pthread_once_success) {
        if (init_routine != nullptr) {
            init_routine();
        }
        return 0;
    }
    return -1;
}

// Function under test (assuming it's in global namespace)
static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (__once, __func);
  else
    return -1;
}

// Test helper variables
static int test_function_call_count = 0;

// Test helper function
void test_initialization_function() {
    test_function_call_count++;
}

void empty_test_function() {
    // Empty function for testing
}

// Test Suite for __gthread_once function
class GThreadOnceTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Reset mock states before each test
        mock_gthread_active = true;
        mock_pthread_once_success = true;
        mock_pthread_once_call_count = 0;
        test_function_call_count = 0;
    }

    void TearDown() override {
        // Clean up after each test if needed
    }

    __gthread_once_t once_control;
};

// Positive Test Cases
TEST_F(GThreadOnceTest, SuccessfulExecutionWithActiveGThread) {
    // Test successful execution when gthread is active
    mock_gthread_active = true;
    mock_pthread_once_success = true;
    
    int result = __gthread_once(&once_control, test_initialization_function);
    
    EXPECT_EQ(result, 0);
    EXPECT_EQ(mock_pthread_once_call_count, 1);
    EXPECT_EQ(test_function_call_count, 1);
}

TEST_F(GThreadOnceTest, SuccessfulExecutionWithNullFunction) {
    // Test successful execution with null function pointer
    mock_gthread_active = true;
    mock_pthread_once_success = true;
    
    int result = __gthread_once(&once_control, nullptr);
    
    EXPECT_EQ(result, 0);
    EXPECT_EQ(mock_pthread_once_call_count, 1);
}

TEST_F(GThreadOnceTest, SuccessfulExecutionWithEmptyFunction) {
    // Test successful execution with empty function
    mock_gthread_active = true;
    mock_pthread_once_success = true;
    
    int result = __gthread_once(&once_control, empty_test_function);
    
    EXPECT_EQ(result, 0);
    EXPECT_EQ(mock_pthread_once_call_count, 1);
}

// Negative Test Cases
TEST_F(GThreadOnceTest, FailureWhenGThreadInactive) {
    // Test failure when gthread is not active
    mock_gthread_active = false;
    
    int result = __gthread_once(&once_control, test_initialization_function);
    
    EXPECT_EQ(result, -1);
    EXPECT_EQ(mock_pthread_once_call_count, 0);
    EXPECT_EQ(test_function_call_count, 0);
}

TEST_F(GThreadOnceTest, FailureWhenPthreadOnceFails) {
    // Test failure when pthread_once fails
    mock_gthread_active = true;
    mock_pthread_once_success = false;
    
    int result = __gthread_once(&once_control, test_initialization_function);
    
    EXPECT_EQ(result, -1);
    EXPECT_EQ(mock_pthread_once_call_count, 1);
    EXPECT_EQ(test_function_call_count, 1); // Function still gets called in our mock
}

TEST_F(GThreadOnceTest, FailureWithNullOnceControl) {
    // Test behavior with null once control pointer
    mock_gthread_active = true;
    mock_pthread_once_success = true;
    
    int result = __gthread_once(nullptr, test_initialization_function);
    
    EXPECT_EQ(result, 0); // Our mock doesn't validate null pointer
    EXPECT_EQ(mock_pthread_once_call_count, 1);
}

// Edge Cases
TEST_F(GThreadOnceTest, EdgeCaseGThreadActiveTransition) {
    // Test edge case where gthread becomes inactive during execution
    mock_gthread_active = true;
    
    // First call should succeed
    int result1 = __gthread_once(&once_control, test_initialization_function);
    EXPECT_EQ(result1, 0);
    
    // Change state and make another call
    mock_gthread_active = false;
    __gthread_once_t another_once_control;
    int result2 = __gthread_once(&another_once_control, test_initialization_function);
    EXPECT_EQ(result2, -1);
}

TEST_F(GThreadOnceTest, EdgeCaseMultipleCallsWithSameOnceControl) {
    // Test multiple calls with the same once control
    mock_gthread_active = true;
    mock_pthread_once_success = true;
    
    int result1 = __gthread_once(&once_control, test_initialization_function);
    int result2 = __gthread_once(&once_control, test_initialization_function);
    
    EXPECT_EQ(result1, 0);
    EXPECT_EQ(result2, 0);
    EXPECT_EQ(mock_pthread_once_call_count, 2);
}

TEST_F(GThreadOnceTest, EdgeCaseBoundaryConditionActiveCheck) {
    // Test boundary condition for active check
    mock_gthread_active = false;
    
    int result = __gthread_once(&once_control, test_initialization_function);
    
    EXPECT_EQ(result, -1);
    EXPECT_EQ(mock_pthread_once_call_count, 0);
    
    // Now activate and test
    mock_gthread_active = true;
    result = __gthread_once(&once_control, test_initialization_function);
    
    EXPECT_EQ(result, 0);
    EXPECT_EQ(mock_pthread_once_call_count, 1);
}

// Performance and Stress Test
TEST_F(GThreadOnceTest, StressTestMultipleSequentialCalls) {
    // Test multiple sequential calls to verify consistent behavior
    mock_gthread_active = true;
    mock_pthread_once_success = true;
    
    const int num_calls = 100;
    for (int i = 0; i < num_calls; ++i) {
        __gthread_once_t local_once_control;
        int result = __gthread_once(&local_once_control, empty_test_function);
        EXPECT_EQ(result, 0);
    }
    
    EXPECT_EQ(mock_pthread_once_call_count, num_calls);
}

// Main function to run all tests
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
