// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <system_error>
#include <cassert>
#include <cmath>
#include <iostream>

// Test suite for std::error_code copy constructor
class ErrorCodeCopyConstructorTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup common test data
    }
    
    void TearDown() override {
        // Cleanup after tests
    }
};

// Positive test cases
TEST_F(ErrorCodeCopyConstructorTest, CopyConstructorWithDefaultErrorCode) {
    // Test copying a default-constructed error_code
    std::error_code original;
    std::error_code copied(original);
    
    EXPECT_EQ(original.value(), copied.value());
    EXPECT_EQ(original.category(), copied.category());
    EXPECT_EQ(original.message(), copied.message());
    EXPECT_FALSE(copied);  // Default error_code should evaluate to false
}

TEST_F(ErrorCodeCopyConstructorTest, CopyConstructorWithValidErrorCode) {
    // Test copying an error_code with a specific error value
    std::error_code original = std::make_error_code(std::errc::invalid_argument);
    std::error_code copied(original);
    
    EXPECT_EQ(original.value(), copied.value());
    EXPECT_EQ(original.category(), copied.category());
    EXPECT_EQ(original.message(), copied.message());
    EXPECT_TRUE(copied);  // Non-zero error_code should evaluate to true
}

TEST_F(ErrorCodeCopyConstructorTest, CopyConstructorWithSystemErrorCode) {
    // Test copying an error_code from system category
    std::error_code original(EINVAL, std::system_category());
    std::error_code copied(original);
    
    EXPECT_EQ(original.value(), copied.value());
    EXPECT_EQ(&original.category(), &copied.category());
    EXPECT_EQ(original.message(), copied.message());
    EXPECT_TRUE(copied);
}

// Negative test cases
TEST_F(ErrorCodeCopyConstructorTest, CopyConstructorIndependence) {
    // Test that copied error_code is independent of original
    std::error_code original = std::make_error_code(std::errc::permission_denied);
    std::error_code copied(original);
    
    // Modify original by assigning a different error
    original = std::make_error_code(std::errc::file_exists);
    
    // Copied should remain unchanged
    EXPECT_NE(original.value(), copied.value());
    EXPECT_EQ(copied.value(), static_cast<int>(std::errc::permission_denied));
}

TEST_F(ErrorCodeCopyConstructorTest, CopyConstructorWithDifferentCategories) {
    // Test copying error_codes from different categories
    std::error_code original_generic = std::make_error_code(std::errc::bad_file_descriptor);
    std::error_code original_system(EBADF, std::system_category());
    
    std::error_code copied_generic(original_generic);
    std::error_code copied_system(original_system);
    
    // Verify they maintain their distinct categories
    EXPECT_EQ(&original_generic.category(), &copied_generic.category());
    EXPECT_EQ(&original_system.category(), &copied_system.category());
    EXPECT_NE(&copied_generic.category(), &copied_system.category());
}

// Edge case tests
TEST_F(ErrorCodeCopyConstructorTest, CopyConstructorWithMaxErrorValue) {
    // Test copying error_code with maximum possible error value
    std::error_code original(INT_MAX, std::generic_category());
    std::error_code copied(original);
    
    EXPECT_EQ(original.value(), copied.value());
    EXPECT_EQ(original.value(), INT_MAX);
    EXPECT_EQ(&original.category(), &copied.category());
}

TEST_F(ErrorCodeCopyConstructorTest, CopyConstructorChaining) {
    // Test multiple copy constructions in a chain
    std::error_code original = std::make_error_code(std::errc::operation_not_permitted);
    std::error_code first_copy(original);
    std::error_code second_copy(first_copy);
    std::error_code third_copy(second_copy);
    
    // All copies should be identical to original
    EXPECT_EQ(original.value(), first_copy.value());
    EXPECT_EQ(original.value(), second_copy.value());
    EXPECT_EQ(original.value(), third_copy.value());
    
    EXPECT_EQ(&original.category(), &first_copy.category());
    EXPECT_EQ(&original.category(), &second_copy.category());
    EXPECT_EQ(&original.category(), &third_copy.category());
}

TEST_F(ErrorCodeCopyConstructorTest, CopyConstructorSelfAssignmentSafety) {
    // Test that the copy constructor works correctly even in edge scenarios
    std::error_code original = std::make_error_code(std::errc::resource_unavailable_try_again);
    std::error_code copied(original);
    
    // Verify the copy is complete and accurate
    EXPECT_EQ(original.value(), copied.value());
    EXPECT_EQ(original.message(), copied.message());
    EXPECT_EQ(&original.category(), &copied.category());
    
    // Ensure both objects are in valid states
    EXPECT_TRUE(original);
    EXPECT_TRUE(copied);
}

// Additional comprehensive test for error_code behavior
TEST_F(ErrorCodeCopyConstructorTest, CopyConstructorPreservesErrorState) {
    // Test that all aspects of error state are preserved
    std::error_code original = std::make_error_code(std::errc::no_such_file_or_directory);
    std::error_code copied(original);
    
    // Test all comparison operators work correctly
    EXPECT_TRUE(original == copied);
    EXPECT_FALSE(original != copied);
    EXPECT_FALSE(original < copied);
    EXPECT_FALSE(copied < original);
    
    // Test boolean conversion
    EXPECT_EQ(static_cast<bool>(original), static_cast<bool>(copied));
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
