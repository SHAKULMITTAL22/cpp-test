// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <cassert>
#include <cmath>
#include <iostream>

// Mock implementation for testing purposes
namespace std {
    struct _Words {
        void* _M_pword;
        long _M_iword;
        _Words() : _M_pword(nullptr), _M_iword(0) {}
    };

    class MockIosBase {
    public:
        static const int _S_local_word_size = 8;
        _Words _M_local_word[_S_local_word_size];
        _Words* _M_word;
        int _M_word_size;
        _Words _M_word_zero;

        MockIosBase() : _M_word(_M_local_word), _M_word_size(_S_local_word_size) {
            // Initialize local words
            for (int i = 0; i < _S_local_word_size; ++i) {
                _M_local_word[i]._M_pword = nullptr;
                _M_local_word[i]._M_iword = 0;
            }
        }

        ~MockIosBase() {
            if (_M_word != _M_local_word) {
                delete[] _M_word;
            }
        }

        _Words& _M_grow_words(int __ix, bool __iword) {
            if (__ix >= _M_word_size) {
                int new_size = __ix + 1;
                _Words* new_words = new _Words[new_size];
                
                // Copy existing words
                for (int i = 0; i < _M_word_size; ++i) {
                    new_words[i] = _M_word[i];
                }
                
                // Initialize new words
                for (int i = _M_word_size; i < new_size; ++i) {
                    new_words[i]._M_pword = nullptr;
                    new_words[i]._M_iword = 0;
                }
                
                if (_M_word != _M_local_word) {
                    delete[] _M_word;
                }
                
                _M_word = new_words;
                _M_word_size = new_size;
            }
            return _M_word[__ix];
        }

        void*& pword(int __ix) {
            _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
                            ? _M_word[__ix] : _M_grow_words(__ix, false);
            return __word._M_pword;
        }
    };
}

// Test Suite for pword function
class PwordTest : public ::testing::Test {
protected:
    void SetUp() override {
        mock_ios_base = new std::MockIosBase();
    }

    void TearDown() override {
        delete mock_ios_base;
    }

    std::MockIosBase* mock_ios_base;
};

// Positive Test Cases
TEST_F(PwordTest, AccessValidIndexWithinLocalWordSize) {
    // Test accessing a valid index within the local word size
    int test_index = 3;
    void* test_ptr = reinterpret_cast<void*>(0x12345678);
    
    void*& pword_ref = mock_ios_base->pword(test_index);
    pword_ref = test_ptr;
    
    EXPECT_EQ(pword_ref, test_ptr);
    EXPECT_EQ(mock_ios_base->_M_word[test_index]._M_pword, test_ptr);
}

TEST_F(PwordTest, AccessZeroIndex) {
    // Test accessing index 0 (first element)
    void* test_ptr = reinterpret_cast<void*>(0xABCDEF00);
    
    void*& pword_ref = mock_ios_base->pword(0);
    pword_ref = test_ptr;
    
    EXPECT_EQ(pword_ref, test_ptr);
    EXPECT_EQ(mock_ios_base->_M_word[0]._M_pword, test_ptr);
}

// Negative Test Cases
TEST_F(PwordTest, AccessLargeIndexTriggersGrowth) {
    // Test accessing an index that exceeds current word size
    int large_index = 15;
    void* test_ptr = reinterpret_cast<void*>(0xDEADBEEF);
    
    int original_size = mock_ios_base->_M_word_size;
    void*& pword_ref = mock_ios_base->pword(large_index);
    pword_ref = test_ptr;
    
    EXPECT_GT(mock_ios_base->_M_word_size, original_size);
    EXPECT_EQ(pword_ref, test_ptr);
    EXPECT_EQ(mock_ios_base->_M_word[large_index]._M_pword, test_ptr);
}

TEST_F(PwordTest, AccessVeryLargeIndex) {
    // Test accessing a very large index
    int very_large_index = 1000;
    void* test_ptr = reinterpret_cast<void*>(0xCAFEBABE);
    
    void*& pword_ref = mock_ios_base->pword(very_large_index);
    pword_ref = test_ptr;
    
    EXPECT_GE(mock_ios_base->_M_word_size, very_large_index + 1);
    EXPECT_EQ(pword_ref, test_ptr);
    EXPECT_EQ(mock_ios_base->_M_word[very_large_index]._M_pword, test_ptr);
}

// Edge Case Tests
TEST_F(PwordTest, AccessBoundaryIndexAtWordSizeLimit) {
    // Test accessing index at the boundary of current word size
    int boundary_index = mock_ios_base->_M_word_size - 1;
    void* test_ptr = reinterpret_cast<void*>(0x11223344);
    
    void*& pword_ref = mock_ios_base->pword(boundary_index);
    pword_ref = test_ptr;
    
    EXPECT_EQ(pword_ref, test_ptr);
    EXPECT_EQ(mock_ios_base->_M_word[boundary_index]._M_pword, test_ptr);
}

TEST_F(PwordTest, MultipleAccessesSameIndex) {
    // Test multiple accesses to the same index return the same reference
    int test_index = 5;
    void* first_ptr = reinterpret_cast<void*>(0x55555555);
    void* second_ptr = reinterpret_cast<void*>(0x66666666);
    
    void*& first_ref = mock_ios_base->pword(test_index);
    first_ref = first_ptr;
    
    void*& second_ref = mock_ios_base->pword(test_index);
    EXPECT_EQ(second_ref, first_ptr);
    
    second_ref = second_ptr;
    EXPECT_EQ(first_ref, second_ptr);
    EXPECT_EQ(&first_ref, &second_ref);
}

TEST_F(PwordTest, InitialValueIsNull) {
    // Test that initial pword values are null
    int test_index = 2;
    
    void*& pword_ref = mock_ios_base->pword(test_index);
    
    EXPECT_EQ(pword_ref, nullptr);
}

TEST_F(PwordTest, PreservesExistingDataAfterGrowth) {
    // Test that existing data is preserved when array grows
    int small_index = 3;
    int large_index = 20;
    void* small_ptr = reinterpret_cast<void*>(0x12345678);
    void* large_ptr = reinterpret_cast<void*>(0x87654321);
    
    // Set value at small index
    void*& small_ref = mock_ios_base->pword(small_index);
    small_ref = small_ptr;
    
    // Access large index to trigger growth
    void*& large_ref = mock_ios_base->pword(large_index);
    large_ref = large_ptr;
    
    // Verify small index value is preserved
    void*& small_ref_after = mock_ios_base->pword(small_index);
    EXPECT_EQ(small_ref_after, small_ptr);
    EXPECT_EQ(large_ref, large_ptr);
}

TEST_F(PwordTest, ReferenceValidityAfterModification) {
    // Test that reference remains valid after modification
    int test_index = 4;
    void* first_value = reinterpret_cast<void*>(0xAAAAAAAA);
    void* second_value = reinterpret_cast<void*>(0xBBBBBBBB);
    
    void*& pword_ref = mock_ios_base->pword(test_index);
    pword_ref = first_value;
    
    EXPECT_EQ(pword_ref, first_value);
    
    pword_ref = second_value;
    EXPECT_EQ(pword_ref, second_value);
    EXPECT_EQ(mock_ios_base->_M_word[test_index]._M_pword, second_value);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
