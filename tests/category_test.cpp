// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <system_error>
#include <memory>

// Test fixture for error_condition category tests
class ErrorConditionCategoryTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Create error_condition objects for testing
        generic_condition = std::error_condition(std::errc::invalid_argument);
        system_condition = std::error_condition(ENOENT, std::system_category());
        default_condition = std::error_condition();
    }

    std::error_condition generic_condition;
    std::error_condition system_condition;
    std::error_condition default_condition;
};

// Test Suite: ErrorConditionCategory - Normal Operation Tests
TEST_F(ErrorConditionCategoryTest, CategoryReturnsGenericCategoryForGenericCondition) {
    const std::error_category& cat = generic_condition.category();
    
    EXPECT_EQ(&cat, &std::generic_category());
    EXPECT_STREQ(cat.name(), "generic");
}

TEST_F(ErrorConditionCategoryTest, CategoryReturnsSystemCategoryForSystemCondition) {
    const std::error_category& cat = system_condition.category();
    
    EXPECT_EQ(&cat, &std::system_category());
    EXPECT_STREQ(cat.name(), "system");
}

// Test Suite: ErrorConditionCategory - Positive Test Cases
TEST_F(ErrorConditionCategoryTest, CategoryReturnsSameCategoryAfterMultipleCalls) {
    const std::error_category& cat1 = generic_condition.category();
    const std::error_category& cat2 = generic_condition.category();
    
    EXPECT_EQ(&cat1, &cat2);
    EXPECT_EQ(&cat1, &std::generic_category());
}

TEST_F(ErrorConditionCategoryTest, CategoryIsConsistentWithConstructorCategory) {
    std::error_condition custom_condition(42, std::generic_category());
    const std::error_category& cat = custom_condition.category();
    
    EXPECT_EQ(&cat, &std::generic_category());
    EXPECT_EQ(custom_condition.value(), 42);
}

// Test Suite: ErrorConditionCategory - Edge Cases
TEST_F(ErrorConditionCategoryTest, CategoryWorksWithDefaultConstructedCondition) {
    const std::error_category& cat = default_condition.category();
    
    // Default constructed error_condition should have system_category
    EXPECT_EQ(&cat, &std::system_category());
    EXPECT_EQ(default_condition.value(), 0);
}

// Test Suite: ErrorConditionCategory - Boundary Conditions
TEST_F(ErrorConditionCategoryTest, CategoryWithMaximumErrorValue) {
    std::error_condition max_condition(INT_MAX, std::generic_category());
    const std::error_category& cat = max_condition.category();
    
    EXPECT_EQ(&cat, &std::generic_category());
    EXPECT_EQ(max_condition.value(), INT_MAX);
}

TEST_F(ErrorConditionCategoryTest, CategoryWithZeroErrorValue) {
    std::error_condition zero_condition(0, std::generic_category());
    const std::error_category& cat = zero_condition.category();
    
    EXPECT_EQ(&cat, &std::generic_category());
    EXPECT_EQ(zero_condition.value(), 0);
}

// Test Suite: ErrorConditionCategory - Negative Test Cases
TEST_F(ErrorConditionCategoryTest, CategoryWithNegativeErrorValue) {
    std::error_condition negative_condition(-1, std::system_category());
    const std::error_category& cat = negative_condition.category();
    
    EXPECT_EQ(&cat, &std::system_category());
    EXPECT_EQ(negative_condition.value(), -1);
}

TEST_F(ErrorConditionCategoryTest, CategoryRemainsValidAfterConditionCopy) {
    std::error_condition original(std::errc::permission_denied);
    std::error_condition copied = original;
    
    const std::error_category& original_cat = original.category();
    const std::error_category& copied_cat = copied.category();
    
    EXPECT_EQ(&original_cat, &copied_cat);
    EXPECT_EQ(&original_cat, &std::generic_category());
}

// Test Suite: ErrorConditionCategory - Const Correctness
TEST_F(ErrorConditionCategoryTest, CategoryMethodIsNoexceptAndConst) {
    const std::error_condition const_condition(std::errc::operation_not_permitted);
    
    // This should compile without issues due to const and noexcept qualifiers
    const std::error_category& cat = const_condition.category();
    
    EXPECT_EQ(&cat, &std::generic_category());
    
    // Verify the method doesn't modify the object state
    EXPECT_EQ(const_condition.value(), static_cast<int>(std::errc::operation_not_permitted));
}

// Test Suite: ErrorConditionCategory - Reference Stability
TEST_F(ErrorConditionCategoryTest, CategoryReferenceRemainsValidThroughObjectLifetime) {
    const std::error_category* cat_ptr = nullptr;
    
    {
        std::error_condition temp_condition(std::errc::bad_message);
        cat_ptr = &temp_condition.category();
        
        // Category reference should point to a static object
        EXPECT_EQ(cat_ptr, &std::generic_category());
    }
    
    // The category should still be valid even after temp_condition is destroyed
    // because it points to a static category object
    EXPECT_STREQ(cat_ptr->name(), "generic");
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
