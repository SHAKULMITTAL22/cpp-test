// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514

ROOST_METHOD_HASH=babylonian_method_047d929d2a
ROOST_METHOD_SIG_HASH=babylonian_method_b623b90fe5

double babylonian_method(double radicand) {

// ********RoostGPT********
#include <gtest/gtest.h>
#include <cmath>
#include <limits>

namespace numerical_methods {
    double babylonian_method(double radicand);
}

class BabylonianMethodTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
    
    // Helper function to compare floating point numbers with tolerance
    bool isApproximatelyEqual(double a, double b, double tolerance = 1e-9) {
        return std::abs(a - b) < tolerance;
    }
};

// Test Suite for Babylonian Method Square Root Calculation
TEST_F(BabylonianMethodTest, PositiveIntegerSquareRoot) {
    // Test perfect square
    double result = numerical_methods::babylonian_method(25.0);
    EXPECT_TRUE(isApproximatelyEqual(result, 5.0));
    
    // Test another perfect square
    result = numerical_methods::babylonian_method(16.0);
    EXPECT_TRUE(isApproximatelyEqual(result, 4.0));
}

TEST_F(BabylonianMethodTest, PositiveDecimalSquareRoot) {
    // Test non-perfect square
    double result = numerical_methods::babylonian_method(2.0);
    EXPECT_TRUE(isApproximatelyEqual(result, std::sqrt(2.0), 1e-4));
    
    // Test decimal input
    result = numerical_methods::babylonian_method(10.5);
    EXPECT_TRUE(isApproximatelyEqual(result, std::sqrt(10.5), 1e-4));
}

TEST_F(BabylonianMethodTest, EdgeCaseZeroInput) {
    // Test zero input
    double result = numerical_methods::babylonian_method(0.0);
    EXPECT_TRUE(isApproximatelyEqual(result, 0.0));
}

TEST_F(BabylonianMethodTest, EdgeCaseOneInput) {
    // Test input of 1
    double result = numerical_methods::babylonian_method(1.0);
    EXPECT_TRUE(isApproximatelyEqual(result, 1.0));
}

TEST_F(BabylonianMethodTest, SmallPositiveNumber) {
    // Test very small positive number
    double result = numerical_methods::babylonian_method(0.01);
    EXPECT_TRUE(isApproximatelyEqual(result, 0.1, 1e-4));
    
    // Test fractional input less than 1
    result = numerical_methods::babylonian_method(0.25);
    EXPECT_TRUE(isApproximatelyEqual(result, 0.5, 1e-4));
}

TEST_F(BabylonianMethodTest, LargePositiveNumber) {
    // Test large number
    double result = numerical_methods::babylonian_method(10000.0);
    EXPECT_TRUE(isApproximatelyEqual(result, 100.0, 1e-4));
    
    // Test another large number
    result = numerical_methods::babylonian_method(144.0);
    EXPECT_TRUE(isApproximatelyEqual(result, 12.0));
}

TEST_F(BabylonianMethodTest, NegativeInputHandling) {
    // Test negative input - should return NaN or handle gracefully
    double result = numerical_methods::babylonian_method(-4.0);
    EXPECT_TRUE(std::isnan(result) || result != result);
    
    // Test another negative input
    result = numerical_methods::babylonian_method(-1.0);
    EXPECT_TRUE(std::isnan(result) || result != result);
}

TEST_F(BabylonianMethodTest, VeryLargeNumber) {
    // Test with a very large number to check numerical stability
    double result = numerical_methods::babylonian_method(1000000.0);
    EXPECT_TRUE(isApproximatelyEqual(result, 1000.0, 1e-3));
}

TEST_F(BabylonianMethodTest, AccuracyComparison) {
    // Compare accuracy with standard library sqrt function
    double test_values[] = {4.0, 9.0, 15.0, 50.0, 100.0};
    
    for (double value : test_values) {
        double babylonian_result = numerical_methods::babylonian_method(value);
        double standard_result = std::sqrt(value);
        
        // Expect results to be close within reasonable tolerance
        EXPECT_TRUE(isApproximatelyEqual(babylonian_result, standard_result, 1e-3))
            << "Failed for input: " << value 
            << " Babylonian: " << babylonian_result 
            << " Standard: " << standard_result;
    }
}

TEST_F(BabylonianMethodTest, ConvergenceBehavior) {
    // Test that the method converges for typical inputs
    double result1 = numerical_methods::babylonian_method(7.0);
    double result2 = numerical_methods::babylonian_method(13.0);
    
    // Results should be finite and positive
    EXPECT_TRUE(std::isfinite(result1));
    EXPECT_GT(result1, 0.0);
    EXPECT_TRUE(std::isfinite(result2));
    EXPECT_GT(result2, 0.0);
    
    // Verify approximate correctness
    EXPECT_TRUE(isApproximatelyEqual(result1 * result1, 7.0, 1e-3));
    EXPECT_TRUE(isApproximatelyEqual(result2 * result2, 13.0, 1e-3));
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
