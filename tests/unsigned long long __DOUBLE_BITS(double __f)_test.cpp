// ********RoostGPT********
// Test generated by RoostGPT for test cpp-test-1908 using AI Type Claude AI and AI Model claude-sonnet-4-20250514



// ********RoostGPT********
#include <gtest/gtest.h>
#include <cmath>
#include <limits>
#include <cstdint>

// Function under test - assuming it's in a namespace or needs to be declared
static inline unsigned long long __DOUBLE_BITS(double __f)
{
    union {double __f; unsigned long long __i;} __u;
    __u.__f = __f;
    return __u.__i;
}

// Test suite for __DOUBLE_BITS function
class DoubleBitsTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

// Positive test cases
TEST_F(DoubleBitsTest, PositiveNormalValue) {
    double test_value = 1.0;
    unsigned long long result = __DOUBLE_BITS(test_value);
    
    // IEEE 754 representation of 1.0 is 0x3FF0000000000000
    EXPECT_EQ(result, 0x3FF0000000000000ULL);
}

TEST_F(DoubleBitsTest, PositiveFractionalValue) {
    double test_value = 0.5;
    unsigned long long result = __DOUBLE_BITS(test_value);
    
    // IEEE 754 representation of 0.5 is 0x3FE0000000000000
    EXPECT_EQ(result, 0x3FE0000000000000ULL);
}

TEST_F(DoubleBitsTest, PositiveZero) {
    double test_value = 0.0;
    unsigned long long result = __DOUBLE_BITS(test_value);
    
    // IEEE 754 representation of +0.0 is 0x0000000000000000
    EXPECT_EQ(result, 0x0000000000000000ULL);
}

// Negative test cases
TEST_F(DoubleBitsTest, NegativeNormalValue) {
    double test_value = -1.0;
    unsigned long long result = __DOUBLE_BITS(test_value);
    
    // IEEE 754 representation of -1.0 is 0xBFF0000000000000
    EXPECT_EQ(result, 0xBFF0000000000000ULL);
}

TEST_F(DoubleBitsTest, NegativeZero) {
    double test_value = -0.0;
    unsigned long long result = __DOUBLE_BITS(test_value);
    
    // IEEE 754 representation of -0.0 is 0x8000000000000000
    EXPECT_EQ(result, 0x8000000000000000ULL);
}

// Edge case tests
TEST_F(DoubleBitsTest, PositiveInfinity) {
    double test_value = std::numeric_limits<double>::infinity();
    unsigned long long result = __DOUBLE_BITS(test_value);
    
    // IEEE 754 representation of +infinity is 0x7FF0000000000000
    EXPECT_EQ(result, 0x7FF0000000000000ULL);
}

TEST_F(DoubleBitsTest, NegativeInfinity) {
    double test_value = -std::numeric_limits<double>::infinity();
    unsigned long long result = __DOUBLE_BITS(test_value);
    
    // IEEE 754 representation of -infinity is 0xFFF0000000000000
    EXPECT_EQ(result, 0xFFF0000000000000ULL);
}

TEST_F(DoubleBitsTest, QuietNaN) {
    double test_value = std::numeric_limits<double>::quiet_NaN();
    unsigned long long result = __DOUBLE_BITS(test_value);
    
    // NaN has exponent bits all 1 and non-zero mantissa
    // Check that exponent bits (bits 52-62) are all 1
    EXPECT_EQ((result >> 52) & 0x7FF, 0x7FF);
    // Check that mantissa (bits 0-51) is non-zero for NaN
    EXPECT_NE(result & 0xFFFFFFFFFFFFFULL, 0ULL);
}

TEST_F(DoubleBitsTest, MaxDoubleValue) {
    double test_value = std::numeric_limits<double>::max();
    unsigned long long result = __DOUBLE_BITS(test_value);
    
    // IEEE 754 representation of max double is 0x7FEFFFFFFFFFFFFF
    EXPECT_EQ(result, 0x7FEFFFFFFFFFFFFFULL);
}

TEST_F(DoubleBitsTest, MinDoubleValue) {
    double test_value = std::numeric_limits<double>::lowest();
    unsigned long long result = __DOUBLE_BITS(test_value);
    
    // IEEE 754 representation of lowest double is 0xFFEFFFFFFFFFFFFF
    EXPECT_EQ(result, 0xFFEFFFFFFFFFFFFFULL);
}

TEST_F(DoubleBitsTest, SmallestPositiveNormal) {
    double test_value = std::numeric_limits<double>::min();
    unsigned long long result = __DOUBLE_BITS(test_value);
    
    // IEEE 754 representation of smallest positive normal double
    EXPECT_EQ(result, 0x0010000000000000ULL);
}

TEST_F(DoubleBitsTest, DenormalizedNumber) {
    double test_value = std::numeric_limits<double>::denorm_min();
    unsigned long long result = __DOUBLE_BITS(test_value);
    
    // IEEE 754 representation of smallest positive denormalized double
    EXPECT_EQ(result, 0x0000000000000001ULL);
}

// Test for bit pattern consistency
TEST_F(DoubleBitsTest, BitPatternConsistency) {
    double test_values[] = {2.0, 4.0, 8.0, 16.0};
    
    for (double val : test_values) {
        unsigned long long result = __DOUBLE_BITS(val);
        
        // Verify that the function returns a valid bit pattern
        // All bits should be accessible and the result should be deterministic
        EXPECT_EQ(__DOUBLE_BITS(val), result) << "Function should be deterministic for value: " << val;
    }
}

// Test for special floating point values
TEST_F(DoubleBitsTest, SpecialFloatingPointValues) {
    // Test various powers of 2
    double power_of_two = 1024.0; // 2^10
    unsigned long long result = __DOUBLE_BITS(power_of_two);
    
    // For powers of 2, mantissa should be 0 and exponent should be biased
    // 1024 = 2^10, so exponent should be 1023 + 10 = 1033 = 0x409
    EXPECT_EQ((result >> 52) & 0x7FF, 0x409);
    EXPECT_EQ(result & 0xFFFFFFFFFFFFFULL, 0ULL);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
